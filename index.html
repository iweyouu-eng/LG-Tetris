<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Tetris (NES 룰) + BGM v4.2</title>
<style>
  :root { --bg:#0f1115; --panel:rgba(255,255,255,0.06); --accent:#7dd3fc; }
  html, body { margin:0; padding:0; height:100%; background:linear-gradient(180deg,#0f1115,#0b0d11); color:#e5e7eb; font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,Arial,sans-serif; }
  .wrap { max-width:1100px; margin:0 auto; padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; }
  @media (min-width: 950px){ .wrap { grid-template-columns: 0.9fr 1.1fr; } }
  .card { background: var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
  #stage { position:relative; display:flex; justify-content:center; align-items:center; min-height:60vh; }
  #game { background:#111; border:1px solid rgba(255,255,255,.1); border-radius:8px; image-rendering: pixelated; }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); border-radius:10px; }
  #overlay.hidden { display:none; }
  #overlay .box { text-align:center; }
  .btn { background:#1f2937; color:#fff; border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:10px 12px; cursor:pointer; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  #stats { display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:8px; }
  .stat { background:rgba(0,0,0,0.35); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.08); }
  .strong { font-weight:800; color:#fff; }
  .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .note { font-size:12px; color:#cbd5e1; }
  .grid { display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:6px; margin-top:8px; }
  .kbd { background:#0b1220; border:1px solid rgba(255,255,255,.15); padding:6px 8px; border-radius:8px; font-size:12px; }
  #pad { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; margin-top:8px; }
  #pad .btn { padding:12px; }
  @media (min-width: 900px){ #pad { display:none; } }
  #err { position:fixed; left:10px; bottom:10px; background:#c00; color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; z-index:9999; white-space:pre-wrap; display:none; }
  #dbg { position:fixed; right:10px; bottom:10px; font-size:11px; color:#9ca3af; }
  .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:6px 0; }
  .sep { width:1px; height:20px; background:rgba(255,255,255,.15); display:inline-block; }
  input[type="number"] { width:80px; }
</style>
</head>
<body>
<div id="err"></div>
<div id="dbg"></div>
<div class="wrap">
  <div class="card" id="stage">
    <canvas id="game" width="320" height="640"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 style="margin:0 0 10px 0;">Tetris (NES) + BGM</h2>
        <p class="note">시작을 누르면 오디오 권한이 활성화되고 BGM이 재생됩니다.</p>
        <button id="startBtn" class="btn">▶ 시작</button>
      </div>
    </div>
    <audio id="bgmAudio" preload="auto" loop></audio>
  </div>
  <div class="card">
    <div class="controls">
      <div class="row">
        <button id="btnPause" class="btn">⏸ 일시정지</button>
        <button id="btnReset" class="btn">↺ 리셋</button>
        <span class="sep"></span>
        <label>트랙: 
          <select id="trackSel">
            <option value="A" selected>A</option>
            <option value="B">B</option>
          </select>
        </label>
        <label>🎵 BGM <input type="checkbox" id="bgmToggle" checked></label>
        <label>볼륨 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px;"></label>
      </div>
      <div class="row">
        <label>Loop 사용 <input type="checkbox" id="loopEnable"></label>
        <label>시작(s) <input type="number" id="loopStart" value="0" step="0.1"></label>
        <label>끝(s) <input type="number" id="loopEnd" value="9999" step="0.1"></label>
        <button id="setStart" class="btn">현재→시작</button>
        <button id="setEnd" class="btn">현재→끝</button>
      </div>
      <div class="row">
        <label>Fade In(s) <input type="number" id="fadeIn" value="1.0" min="0" max="10" step="0.1"></label>
        <label>Fade Out(s) <input type="number" id="fadeOut" value="0.6" min="0" max="10" step="0.1"></label>
        <button id="testFade" class="btn">페이드 테스트</button>
      </div>
    </div>
    <div id="stats" style="margin-top:8px;">
      <div class="stat">레벨<br><span id="level" class="strong">0</span></div>
      <div class="stat">점수<br><span id="score" class="strong">0</span></div>
      <div class="stat">라인<br><span id="lines" class="strong">0</span></div>
      <div class="stat">다음<br><canvas id="next" width="96" height="96" style="background:#0b0b0b;border-radius:8px;border:1px solid rgba(255,255,255,.1)"></canvas></div>
    </div>

    <div style="margin-top:10px;">
      <div class="grid">
        <div><span class="kbd">←/→</span> 이동</div>
        <div><span class="kbd">↑</span> 회전</div>
        <div><span class="kbd">↓</span> 소프트 드롭(+1점/칸)</div>
        <div><span class="kbd">P</span> 일시정지 / <span class="kbd">R</span> 리셋</div>
      </div>
      <div id="pad">
        <button class="btn" id="padLeft">←</button>
        <button class="btn" id="padRotate">⟳</button>
        <button class="btn" id="padRight">→</button>
        <button class="btn" id="padDropSoft" style="grid-column: span 3;">↓ 소프트</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  var errEl = document.getElementById('err');
  var dbgEl = document.getElementById('dbg');
  function toast(msg){ try{ errEl.style.display='block'; errEl.textContent=msg; setTimeout(()=>{ errEl.style.display='none'; }, 5000);}catch(e){} }
  window.addEventListener('error', e => toast('에러: ' + (e.message||e.toString())));
  window.addEventListener('unhandledrejection', e => toast('Promise 에러: ' + ((e.reason&&(e.reason.message||e.reason.toString()))||'unknown')));

  // ---------- BGM with WebAudio ----------
  const TRACKS = { A:'bgm_A.mp3', B:'bgm_B.mp3' };
  const bgmEl = document.getElementById('bgmAudio');
  const trackSel = document.getElementById('trackSel');
  const bgmToggle = document.getElementById('bgmToggle');
  const bgmVol = document.getElementById('bgmVol');
  const loopEnable = document.getElementById('loopEnable');
  const loopStartEl = document.getElementById('loopStart');
  const loopEndEl = document.getElementById('loopEnd');
  const setStartBtn = document.getElementById('setStart');
  const setEndBtn = document.getElementById('setEnd');
  const fadeInEl = document.getElementById('fadeIn');
  const fadeOutEl = document.getElementById('fadeOut');
  const testFadeBtn = document.getElementById('testFade');

  let audioCtx = null, srcNode = null, volGain = null, fadeGain = null;
  let loopStart = 0, loopEnd = 9999, loopOn = false;
  let userVol = parseFloat(bgmVol.value);

  async function initAudio(){
    if(audioCtx) return true;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();
      srcNode = audioCtx.createMediaElementSource(bgmEl);
      volGain = audioCtx.createGain();
      fadeGain = audioCtx.createGain();
      volGain.gain.value = userVol;
      fadeGain.gain.value = 0.0;
      srcNode.connect(volGain).connect(fadeGain).connect(audioCtx.destination);
      return true;
    }catch(e){
      toast('오디오 초기화 실패: '+e.message);
      bgmToggle.checked = false;
      return false;
    }
  }

  function fadeTo(target, dur){
    if(!audioCtx || !fadeGain) return;
    const g = fadeGain.gain;
    const now = audioCtx.currentTime;
    try{
      g.setValueAtTime(g.value, now);
      g.linearRampToValueAtTime(target, now + Math.max(0, dur||0));
    }catch{}
  }

  function applyLoopInputs(){
    loopOn = !!loopEnable.checked;
    loopStart = parseFloat(loopStartEl.value)||0;
    loopEnd = parseFloat(loopEndEl.value)||9999;
    if(loopEnd <= loopStart + 0.05){ loopOn=false; }
    bgmEl.loop = !loopOn;
  }

  function setTrack(name){
    const url = TRACKS[name] || TRACKS.A;
    const wasPlaying = !bgmEl.paused;
    const outDur = parseFloat(fadeOutEl.value)||0;
    const inDur = parseFloat(fadeInEl.value)||0;
    if(wasPlaying) fadeTo(0.0, outDur);
    const doSwap = ()=>{
      bgmEl.pause();
      bgmEl.src = url;
      bgmEl.currentTime = loopStart || 0;
      bgmEl.load();
      if(bgmToggle.checked){
        bgmEl.play().then(()=> fadeTo(1.0, inDur)).catch(()=>{});
      }
    };
    if(wasPlaying && outDur>0) setTimeout(doSwap, outDur*1000);
    else doSwap();
  }

  bgmEl.addEventListener('error', ()=>{
    toast('BGM 로드 실패: '+ (bgmEl.src||''));
  });

  bgmVol.addEventListener('input', ()=>{
    userVol = parseFloat(bgmVol.value)||0;
    if(volGain) volGain.gain.value = userVol;
  });
  bgmToggle.addEventListener('change', ()=>{
    if(!audioCtx) return;
    if(bgmToggle.checked){
      const inDur = parseFloat(fadeInEl.value)||0;
      bgmEl.play().then(()=> fadeTo(1.0, inDur)).catch(()=>{});
    } else {
      const outDur = parseFloat(fadeOutEl.value)||0;
      fadeTo(0.0, outDur);
      setTimeout(()=> bgmEl.pause(), outDur*1000);
    }
  });
  trackSel.addEventListener('change', ()=> setTrack(trackSel.value));
  testFadeBtn.addEventListener('click', ()=>{
    const outDur = parseFloat(fadeOutEl.value)||0;
    const inDur = parseFloat(fadeInEl.value)||0;
    fadeTo(0.0, outDur);
    setTimeout(()=>{
      if(bgmEl.paused) bgmEl.play().catch(()=>{});
      fadeTo(1.0, inDur);
    }, Math.max(1, outDur*1000 + 200));
  });

  loopEnable.addEventListener('change', applyLoopInputs);
  loopStartEl.addEventListener('input', applyLoopInputs);
  loopEndEl.addEventListener('input', applyLoopInputs);
  setStartBtn.addEventListener('click', ()=>{ loopStartEl.value = bgmEl.currentTime.toFixed(2); applyLoopInputs(); });
  setEndBtn.addEventListener('click', ()=>{ loopEndEl.value = bgmEl.currentTime.toFixed(2); applyLoopInputs(); });

  // ---------- Game (NES approx) ----------
  const COLS=10, ROWS=20, SIZE=32;
  const COLORS = { I:'#67e8f9', J:'#60a5fa', L:'#f59e0b', O:'#fef08a', S:'#34d399', T:'#c084fc', Z:'#f87171', X:'#0b0d12' };
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]]
  };
  const TYPES = ['I','J','L','O','S','T','Z'];

  // FIX: prevType must be initialized BEFORE pickType/nextType to avoid TDZ
  let prevType = null;
  function pickType(){
    const roll = ()=> TYPES[(Math.random()*TYPES.length)|0];
    let t = roll();
    if(prevType && t===prevType) t = roll();
    prevType = t;
    return t;
  }

  const GFRAMES = { 0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6, 10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2, 20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1 };
  function gravityMsForLevel(lv){ const frames = GFRAMES[Math.min(29, lv)] ?? 48; return Math.max(16, frames*(1000/60)); }

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');
  let board = makeBoard();
  let current = null;
  let nextType = pickType(); // SAFE now
  let dropInterval = gravityMsForLevel(0);
  let lastTime = 0;
  let acc = 0;
  let running = false;
  let score=0, lines=0, level=0;

  const overlay = document.getElementById('overlay');
  document.getElementById('startBtn').addEventListener('click', async ()=>{
    const ok = await initAudio(); // may fail; game continues regardless
    applyLoopInputs();
    setTrack(trackSel.value);     // A or B
    if(ok) fadeTo(1.0, parseFloat(fadeInEl.value)||0);
    overlay.classList.add('hidden');
    startGame();
  });
  document.getElementById('btnPause').addEventListener('click', ()=>{
    running = !running;
    document.getElementById('btnPause').textContent = running? '⏸ 일시정지' : '▶ 재개';
  });
  document.getElementById('btnReset').addEventListener('click', resetGame);

  document.getElementById('padLeft').addEventListener('click', ()=> tryMove(-1,0));
  document.getElementById('padRight').addEventListener('click', ()=> tryMove(1,0));
  document.getElementById('padRotate').addEventListener('click', ()=> rotate());
  document.getElementById('padDropSoft').addEventListener('click', ()=> softDrop());

  window.addEventListener('keydown', (e)=>{
    if(!running) return;
    const k=e.key;
    if(k==='ArrowLeft') tryMove(-1,0);
    else if(k==='ArrowRight') tryMove(1,0);
    else if(k==='ArrowDown') softDrop();
    else if(k==='ArrowUp' || k==='x' || k==='X') rotate();
    else if(k==='p' || k==='P'){ document.getElementById('btnPause').click(); }
    else if(k==='r' || k==='R'){ resetGame(); }
  });

  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++){ b[r]=new Array(COLS).fill(null); } return b; }
  function clone(m){ return m.map(row=>row.slice()); }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--){ row.push(m[y][x]); } out.push(row); } return out; }
  function getShape(t){ return clone(SHAPES[t]); }

  function spawn(){
    const t = nextType; nextType = pickType();
    current = { t, m:getShape(t), x: (COLS/2|0)-2, y: -2 };
    drawNext();
    if(collides(current, current.x, current.y)){ gameOver(); }
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const t=nextType, m=getShape(t), color=COLORS[t];
    const cell=18; const offx= (nextCanvas.width - m[0].length*cell)/2;
    const offy= (nextCanvas.height - m.length*cell)/2;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(m[y][x]) drawCell(nctx, offx+x*cell, offy+y*cell, cell, color);
    }
  }

  function collides(piece, nx, ny, nm){
    const m = nm || piece.m;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(!m[y][x]) continue;
      const bx = nx + x, by = ny + y;
      if(bx<0 || bx>=COLS || by>=ROWS) return true;
      if(by>=0 && board[by][bx]) return true;
    }
    return false;
  }

  function lock(){
    const m=current.m;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(!m[y][x]) continue;
      const bx = current.x + x, by = current.y + y;
      if(by>=0) board[by][bx] = current.t;
    }
    clearLines();
    spawn();
  }

  function clearLines(){
    let cleared=0;
    for(let r=ROWS-1;r>=0;r--){
      if(board[r].every(v=> !!v)){
        board.splice(r,1);
        board.unshift(new Array(COLS).fill(null));
        cleared++; r++;
      }
    }
    if(cleared>0){
      const add = [0,40,100,300,1200][cleared] * (level+1);
      score += add;
      lines += cleared;
      if(lines >= (level+1)*10){
        level++;
        dropInterval = gravityMsForLevel(level);
      }
      updateStats();
    }
  }

  function tryMove(dx,dy){
    const nx = current.x + dx, ny = current.y + dy;
    if(!collides(current, nx, ny)){ current.x=nx; current.y=ny; return true; }
    return false;
  }

  function rotate(){
    let nm = rotateCW(current.m);
    if(!collides(current, current.x, current.y, nm)){ current.m=nm; return true; }
    return false;
  }

  function softDrop(){
    if(tryMove(0,1)){ score += 1; updateStats(); }
    else { lock(); }
  }

  function update(dt){
    if(!running) return;
    acc += dt;
    if(acc >= dropInterval){
      if(!tryMove(0,1)) lock();
      acc = 0;
    }
  }

  function drawCell(c, x,y,s, color){
    c.fillStyle=color; c.fillRect(x,y,s,s);
    c.strokeStyle='rgba(0,0,0,0.35)'; c.lineWidth=2; c.strokeRect(x+1,y+1,s-2,s-2);
    c.strokeStyle='rgba(255,255,255,0.12)'; c.lineWidth=2; c.strokeRect(x+0.5,y+0.5,s-1,s-1);
  }

  function render(){
    const st = document.getElementById('stage');
    const rect = st.getBoundingClientRect();
    const wScale = Math.floor(rect.width/(COLS*SIZE));
    const hScale = Math.floor(rect.height/(ROWS*SIZE));
    const scale = Math.max(1, Math.min(wScale, hScale));
    const cssW = COLS*SIZE*scale, cssH = ROWS*SIZE*scale;
    const style = canvas.style;
    style.width = cssW+'px'; style.height = cssH+'px';

    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      const t = board[y][x];
      drawCell(ctx, x*SIZE, y*SIZE, SIZE, t? COLORS[t] : COLORS.X);
    }
    if(current){
      const m=current.m, color=COLORS[current.t];
      for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
        if(m[y][x]) drawCell(ctx, (current.x+x)*SIZE, (current.y+y)*SIZE, SIZE, color);
      }
    }
  }

  function loop(ts){
    try{
      const dt = ts - lastTime; lastTime = ts;
      update(dt);
      render();
      dbgEl.textContent = 'dt:'+Math.round(dt)+'ms  level:'+level+'  running:'+(running?1:0);
    }catch(e){
      toast('루프 에러: '+e.message);
    }
    requestAnimationFrame(loop);
  }

  function startGame(){
    if(current==null){ spawn(); }
    running = true;
    updateStats();
    requestAnimationFrame(loop);
  }

  function gameOver(){
    running=false;
    toast('Game Over');
    resetGame(true);
  }

  function resetGame(keepOverlay){
    board = makeBoard();
    current = null;
    nextType = pickType();
    dropInterval = gravityMsForLevel(level=0);
    lastTime = 0; acc=0;
    score=0; lines=0;
    updateStats();
    drawNext();
    if(!keepOverlay){ overlay.classList.remove('hidden'); }
  }

  function updateStats(){
    document.getElementById('score').textContent = score;
    document.getElementById('lines').textContent = lines;
    document.getElementById('level').textContent = level;
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const t=nextType, m=getShape(t), color=COLORS[t];
    const cell=18; const offx= (nextCanvas.width - m[0].length*cell)/2;
    const offy= (nextCanvas.height - m.length*cell)/2;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(m[y][x]) drawCell(nctx, offx+x*cell, offy+y*cell, cell, color);
    }
  }

  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++){ b[r]=new Array(COLS).fill(null); } return b; } // moved to bottom to avoid hoist confusion
  function clone(m){ return m.map(row=>row.slice()); }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--){ row.push(m[y][x]); } out.push(row); } return out; }
  function getShape(t){ return clone(SHAPES[t]); }

  // Bootstrap preview
  drawNext();
})();
</script>
</body>
</html>
