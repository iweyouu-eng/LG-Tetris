<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Tetris (NES 룰) + BGM v4.7 [STRICT]</title>
<style>
  :root { --bg:#0f1115; --panel:rgba(255,255,255,0.06); --accent:#7dd3fc; --btn:#1f2937; --btnBorder:rgba(255,255,255,.18); }
  html, body { margin:0; padding:0; height:100%; background:linear-gradient(180deg,#0f1115,#0b0d11); color:#e5e7eb; font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,Arial,sans-serif; }
  .wrap { max-width:1100px; margin:0 auto; padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; padding-bottom: calc(90px + env(safe-area-inset-bottom)); }
  @media (min-width: 950px){ .wrap { grid-template-columns: 0.9fr 1.1fr; padding-bottom: 10px; } }
  .card { background: var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
  #stage { position:relative; display:flex; justify-content:center; align-items:center; min-height:60vh; }
  #game { background:#111; border:1px solid rgba(255,255,255,.1); border-radius:8px; image-rendering: pixelated; outline:none; }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); border-radius:10px; }
  #overlay.hidden { display:none; }
  #overlay .box { text-align:center; }
  .btn { background:var(--btn); color:#fff; border:1px solid var(--btnBorder); border-radius:12px; padding:10px 12px; cursor:pointer; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  #stats { display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:8px; }
  .stat { background:rgba(0,0,0,0.35); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.08); }
  .strong { font-weight:800; color:#fff; }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .note { font-size:12px; color:#cbd5e1; }
  .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:6px 0; }
  .sep { width:1px; height:20px; background:rgba(255,255,255,.15); display:inline-block; }
  input[type="number"] { width:80px; }
  label small { opacity:.8; }
  #err { position:fixed; left:10px; bottom:10px; background:#c00; color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; z-index:9999; white-space:pre-wrap; display:none; }
  #dbg { position:fixed; right:10px; bottom:10px; font-size:11px; color:#9ca3af; }
  #mobileControls {
    position: fixed; left: 0; right: 0; bottom: 0;
    padding: 8px calc(12px + env(safe-area-inset-right)) calc(10px + env(safe-area-inset-bottom)) calc(12px + env(safe-area-inset-left));
    display: flex; justify-content: space-between; align-items: flex-end;
    z-index: 999; pointer-events: none;
  }
  .cluster { display:flex; gap:10px; pointer-events: auto; }
  .mbtn { background: var(--btn); border: 1px solid var(--btnBorder); color: #fff; border-radius:16px;
           display:flex; align-items:center; justify-content:center; width:64px; height:64px; font-size:22px;
           box-shadow: 0 6px 20px rgba(0,0,0,0.35); }
  .mbtn:active { transform: translateY(1px); }
  .hidden { display:none !important; }
  .muted { opacity:.55; pointer-events:none; }
  
  /* Prevent iOS double-tap zoom within game area & mobile controls */
  #stage, #game, #mobileControls, #mobileControls .mbtn { touch-action: none; }
  #mobileControls .mbtn { -webkit-user-select: none; user-select: none; }
  html, body { -webkit-tap-highlight-color: transparent; }

</style>
</head>
<body>
<div id="err"></div>
<div id="dbg"></div>
<div class="wrap">
  <div class="card" id="stage">
    <canvas id="game" width="320" height="640" tabindex="0"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 style="margin:0 0 10px 0;">Tetris (NES) + BGM</h2>
        <p class="note">시작을 누르면 오디오 권한이 활성화되고 BGM이 재생됩니다.</p>
        <button id="startBtn" class="btn">▶ 시작</button>
      </div>
    </div>
    <audio id="bgmAudio" preload="auto"></audio>
  </div>
  <div class="card">
    <div class="controls">
      <div class="row">
        <button id="btnPause" class="btn">⏸ 일시정지</button>
        <button id="btnReset" class="btn">↺ 리셋</button>
        <span class="sep"></span>
        <label>트랙: 
          <select id="trackSel">
            <option value="A" selected>A</option>
            <option value="B">B</option>
            <option value="C">C</option>
          </select>
        </label>
        <label>🎵 BGM <input type="checkbox" id="bgmToggle" checked></label>
        <label>볼륨 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px;"></label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="cycleABC" checked> ABC 자동 순환</label>
        <span class="sep"></span>
        <span id="loopRow">
          <label>Loop 사용 <input type="checkbox" id="loopEnable"></label>
          <label>시작(s) <input type="number" id="loopStart" value="0" step="0.1"></label>
          <label>끝(s) <input type="number" id="loopEnd" value="9999" step="0.1"></label>
          <button id="setStart" class="btn">현재→시작</button>
          <button id="setEnd" class="btn">현재→끝</button>
        </span>
      </div>
      <div class="row">
        <label>Fade In(s) <input type="number" id="fadeIn" value="1.0" min="0" max="10" step="0.1"></label>
        <label>Fade Out(s) <input type="number" id="fadeOut" value="0.6" min="0" max="10" step="0.1"></label>
        <button id="testFade" class="btn">페이드 테스트</button>
      </div>
      <div class="row">
        <label><input type="checkbox" id="lockKeys" checked> 키 입력을 게임에 고정</label>
        <label><input type="checkbox" id="enableHardDrop"> Space=하드드롭(옵션)</label>
      </div>
    </div>
  </div>
</div>

<!-- Mobile Controls (fixed bottom) -->
<div id="mobileControls">
  <div class="cluster left">
    <div class="mbtn" id="mLeft" title="Left">◀</div>
    <div class="mbtn" id="mRight" title="Right">▶</div>
  </div>
  <div class="cluster right">
    <div class="mbtn" id="mRotate" title="Rotate">⟳</div>
    <div class="mbtn" id="mSoft" title="Soft Drop">↓</div>
    <div class="mbtn" id="mHard" title="Hard Drop">⤓</div>
  </div>
</div>

<script>
(function(){
  var errEl = document.getElementById('err');
  var dbgEl = document.getElementById('dbg');
  function toast(msg){ try{ errEl.style.display='block'; errEl.textContent=msg; setTimeout(()=>{ errEl.style.display='none'; }, 5000);}catch(e){} }
  window.addEventListener('error', e => toast('에러: ' + (e.message||e.toString())));
  window.addEventListener('unhandledrejection', e => toast('Promise 에러: ' + ((e.reason&&(e.reason.message||e.reason.toString()))||'unknown')));

  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);

  // Double-tap zoom killer within game/controls
  const mobileControls = document.getElementById('mobileControls');
  const stage = document.getElementById('stage');
  [mobileControls, stage].forEach(el => {
    ['dblclick'].forEach(ev => el.addEventListener(ev, e=>{ e.preventDefault(); }, {passive:false}));
    let last=0;
    el.addEventListener('touchend', e=>{ 
      const now=Date.now();
      if(now-last<320){ e.preventDefault(); }
      last=now;
    }, {passive:false});
  });

  // ---------- BGM with WebAudio & ABC cycle ----------
  const TRACKS = { A:'bgm_A.mp3', B:'bgm_B.mp3', C:'bgm_C.mp3' };
  const order = ['A','B','C'];
  const bgmEl = document.getElementById('bgmAudio');
  const trackSel = document.getElementById('trackSel');
  const bgmToggle = document.getElementById('bgmToggle');
  const bgmVol = document.getElementById('bgmVol');
  const cycleToggle = document.getElementById('cycleABC');
  const loopRow = document.getElementById('loopRow');
  const loopEnable = document.getElementById('loopEnable');
  const loopStartEl = document.getElementById('loopStart');
  const loopEndEl = document.getElementById('loopEnd');
  const setStartBtn = document.getElementById('setStart');
  const setEndBtn = document.getElementById('setEnd');
  const fadeInEl = document.getElementById('fadeIn');
  const fadeOutEl = document.getElementById('fadeOut');
  const testFadeBtn = document.getElementById('testFade');

  let audioCtx = null, srcNode = null, volGain = null, fadeGain = null;
  let loopStart = 0, loopEnd = 9999, loopOn = false;
  let userVol = parseFloat(bgmVol.value);

  async function initAudio(){
    if(audioCtx) return true;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();
      srcNode = audioCtx.createMediaElementSource(bgmEl);
      volGain = audioCtx.createGain();
      fadeGain = audioCtx.createGain();
      volGain.gain.value = userVol;
      fadeGain.gain.value = 0.0;
      srcNode.connect(volGain).connect(fadeGain).connect(audioCtx.destination);
      return true;
    }catch(e){
      toast('오디오 초기화 실패: '+e.message);
      bgmToggle.checked = false;
      return false;
    }
  }

  function fadeTo(target, dur){
    if(!audioCtx || !fadeGain) return;
    const g = fadeGain.gain;
    const now = audioCtx.currentTime;
    try{
      g.setValueAtTime(g.value, now);
      g.linearRampToValueAtTime(target, now + Math.max(0, dur||0));
    }catch{}
  }

  function applyLoopInputs(){
    loopOn = !!loopEnable.checked;
    loopStart = parseFloat(loopStartEl.value)||0;
    loopEnd = parseFloat(loopEndEl.value)||9999;
    if(loopEnd <= loopStart + 0.05){ loopOn=false; }
    updateLoopFlags();
  }

  function updateLoopFlags(){
    if(cycleToggle.checked){
      bgmEl.loop = false;
    } else {
      bgmEl.loop = !loopOn;
    }
    loopRow.classList.toggle('muted', cycleToggle.checked);
  }

  function setTrack(name){
    const url = TRACKS[name] || TRACKS.A;
    const wasPlaying = !bgmEl.paused;
    const outDur = parseFloat(fadeOutEl.value)||0;
    const inDur = parseFloat(fadeInEl.value)||0;
    if(wasPlaying) fadeTo(0.0, outDur);
    const doSwap = ()=>{
      bgmEl.pause();
      bgmEl.src = url;
      bgmEl.currentTime = loopStart || 0;
      bgmEl.load();
      if(bgmToggle.checked){
        bgmEl.play().then(()=> fadeTo(1.0, inDur)).catch(()=>{});
      }
    };
    if(wasPlaying && outDur>0) setTimeout(doSwap, outDur*1000);
    else doSwap();
  }

  function nextTrack(){
    const cur = trackSel.value;
    const idx = order.indexOf(cur);
    const next = order[(idx+1) % order.length];
    trackSel.value = next;
    setTrack(next);
  }

  bgmEl.addEventListener('error', ()=>{
    toast('BGM 로드 실패: '+ (bgmEl.src||''));
  });
  bgmEl.addEventListener('ended', ()=>{
    if(cycleToggle.checked){
      nextTrack();
    }
  });
  bgmEl.addEventListener('timeupdate', ()=>{
    if(cycleToggle.checked) return;
    if(!loopOn) return;
    if(bgmEl.currentTime >= loopEnd - 0.02){
      bgmEl.currentTime = loopStart;
      if(bgmEl.paused && bgmToggle.checked){ bgmEl.play().catch(()=>{}); }
    }
  });

  bgmVol.addEventListener('input', ()=>{
    userVol = parseFloat(bgmVol.value)||0;
    if(volGain) volGain.gain.value = userVol;
  });
  bgmToggle.addEventListener('change', ()=>{
    if(!audioCtx) return;
    if(bgmToggle.checked){
      const inDur = parseFloat(fadeInEl.value)||0;
      bgmEl.play().then(()=> fadeTo(1.0, inDur)).catch(()=>{});
    } else {
      const outDur = parseFloat(fadeOutEl.value)||0;
      fadeTo(0.0, outDur);
      setTimeout(()=> bgmEl.pause(), outDur*1000);
    }
  });
  trackSel.addEventListener('change', ()=> setTrack(trackSel.value));
  testFadeBtn.addEventListener('click', ()=>{
    const outDur = parseFloat(fadeOutEl.value)||0;
    const inDur = parseFloat(fadeInEl.value)||0;
    fadeTo(0.0, outDur);
    setTimeout(()=>{
      if(bgmEl.paused) bgmEl.play().catch(()=>{});
      fadeTo(1.0, inDur);
    }, Math.max(1, outDur*1000 + 200));
  });
  cycleToggle.addEventListener('change', ()=>{
    applyLoopInputs();
  });
  loopEnable.addEventListener('change', applyLoopInputs);
  loopStartEl.addEventListener('input', applyLoopInputs);
  loopEndEl.addEventListener('input', applyLoopInputs);
  setStartBtn.addEventListener('click', ()=>{ loopStartEl.value = bgmEl.currentTime.toFixed(2); applyLoopInputs(); });
  setEndBtn.addEventListener('click', ()=>{ loopEndEl.value = bgmEl.currentTime.toFixed(2); applyLoopInputs(); });

  // ---------- Game (NES approx) ----------
  const COLS=10, ROWS=20, SIZE=32;
  const COLORS = { I:'#67e8f9', J:'#60a5fa', L:'#f59e0b', O:'#fef08a', S:'#34d399', T:'#c084fc', Z:'#f87171', X:'#0b0d12' };
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]]
  };
  const TYPES = ['I','J','L','O','S','T','Z'];

  let prevType = null;
  function pickType(){
    const roll = ()=> TYPES[(Math.random()*TYPES.length)|0];
    let t = roll();
    if(prevType && t===prevType) t = roll();
    prevType = t;
    return t;
  }

  const GFRAMES = { 0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6, 10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2, 20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1 };
  function gravityMsForLevel(lv){ const frames = GFRAMES[Math.min(29, lv)] ?? 48; return Math.max(16, frames*(1000/60)); }

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  let board = makeBoard();
  let current = null;
  let nextType = pickType();
  let dropInterval = gravityMsForLevel(0);
  let lastTime = 0;
  let acc = 0;
  let running = false;
  let score=0, lines=0, level=0;

  const overlay = document.getElementById('overlay');
  document.getElementById('startBtn').addEventListener('click', async ()=>{
    const ok = await initAudio(); 
    applyLoopInputs();
    setTrack(trackSel.value); 
    if(ok) fadeTo(1.0, parseFloat(fadeInEl.value)||0);
    overlay.classList.add('hidden');
    focusGame();
    startGame();
  });
  document.getElementById('btnPause').addEventListener('click', ()=>{
    running = !running;
    document.getElementById('btnPause').textContent = running? '⏸ 일시정지' : '▶ 재개';
    if(running) focusGame();
  });
  document.getElementById('btnReset').addEventListener('click', ()=>{ resetGame(); focusGame(); });

  // On-screen Mobile Buttons (with repeat)
  const mLeft = document.getElementById('mLeft');
  const mRight = document.getElementById('mRight');
  const mRotate = document.getElementById('mRotate');
  const mSoft = document.getElementById('mSoft');
  const mHard = document.getElementById('mHard');

  function holdRepeat(el, fire, das=130, arr=50){
    let t1=null, t2=null;
    const start=(e)=>{ e.preventDefault(); e.stopPropagation(); fire(); t1=setTimeout(()=>{ t2=setInterval(fire, arr); }, das); };
    const end=()=>{ clearTimeout(t1); clearInterval(t2); t1=t2=null; };
    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('touchend', end, {passive:false});
    el.addEventListener('touchcancel', end, {passive:false});
    el.addEventListener('pointerdown', start);
    ['pointerup','pointercancel','pointerleave'].forEach(ev=> el.addEventListener(ev, end));
  }
  holdRepeat(mLeft, ()=>{ if(running) tryMove(-1,0); });
  holdRepeat(mRight, ()=>{ if(running) tryMove(1,0); });
  holdRepeat(mSoft, ()=>{ if(running) tryMove(0,1); }, 0, 50);
  mRotate.addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); if(running) rotate(); });
  mHard.addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); if(running) hardDrop(); });

  // Keyboard capture
  const lockKeysEl = document.getElementById('lockKeys');
  window.addEventListener('keydown', (e)=>{
    const key = e.key;
    const isGameKey = (key==='ArrowLeft'||key==='ArrowRight'||key==='ArrowUp'||key==='ArrowDown'||key===' '||key==='x'||key==='X'||key==='p'||key==='P'||key==='r'||key==='R');
    if(!isGameKey) return;
    if(lockKeysEl.checked){
      e.preventDefault(); e.stopPropagation();
      routeGameKey(e);
    }
  }, true);

  function routeGameKey(e){
    if(!running && !(e.key==='p'||e.key==='P'||e.key==='R'||e.key==='r')) return;
    const k = e.key;
    if(k==='ArrowLeft') tryMove(-1,0);
    else if(k==='ArrowRight') tryMove(1,0);
    else if(k==='ArrowDown') tryMove(0,1);
    else if(k==='ArrowUp' || k==='x' || k==='X') rotate();
    else if(k===' ') hardDrop();
    else if(k==='p' || k==='P'){ document.getElementById('btnPause').click(); }
    else if(k==='r' || k==='R'){ document.getElementById('btnReset').click(); }
  }

  function focusGame(){ document.getElementById('game').focus({preventScroll:true}); }
  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++){ b[r]=new Array(COLS).fill(null); } return b; }
  function clone(m){ return m.map(row=>row.slice()); }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--){ row.push(m[y][x]); } out.push(row); } return out; }
  function getShape(t){ return clone(SHAPES[t]); }

  function spawn(){
    const t = nextType; nextType = pickType();
    current = { t, m:getShape(t), x: (COLS/2|0)-2, y: -2 };
    if(collides(current, current.x, current.y)){ gameOver(); }
  }

  function collides(piece, nx, ny, nm){
    const m = nm || piece.m;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(!m[y][x]) continue;
      const bx = nx + x, by = ny + y;
      if(bx<0 || bx>=COLS || by>=ROWS) return true;
      if(by>=0 && board[by][bx]) return true;
    }
    return false;
  }

  function lock(){
    const m=current.m;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
      if(!m[y][x]) continue;
      const bx = current.x + x, by = current.y + y;
      if(by>=0) board[by][bx] = current.t;
    }
    clearLines();
    spawn();
  }

  function clearLines(){
    let cleared=0;
    for(let r=ROWS-1;r>=0;r--){
      if(board[r].every(v=> !!v)){
        board.splice(r,1);
        board.unshift(new Array(COLS).fill(null));
        cleared++; r++;
      }
    }
    if(cleared>0){
      lines += cleared;
      if(lines >= (level+1)*10){
        level++;
        dropInterval = gravityMsForLevel(level);
      }
    }
  }

  function tryMove(dx,dy){
    const nx = current.x + dx, ny = current.y + dy;
    if(!collides(current, nx, ny)){ current.x=nx; current.y=ny; return true; }
    return false;
  }

  function rotate(){
    let nm = rotateCW(current.m);
    if(!collides(current, current.x, current.y, nm)){ current.m=nm; return true; }
    return false;
  }

  function update(dt){
    if(!running) return;
    acc += dt;
    if(acc >= dropInterval){
      if(!tryMove(0,1)) lock();
      acc = 0;
    }
    render();
  }

  function drawCell(c, x,y,s, color){
    c.fillStyle=color; c.fillRect(x,y,s,s);
    c.strokeStyle='rgba(0,0,0,0.35)'; c.lineWidth=2; c.strokeRect(x+1,y+1,s-2,s-2);
    c.strokeStyle='rgba(255,255,255,0.12)'; c.lineWidth=2; c.strokeRect(x+0.5,y+0.5,s-1,s-1);
  }

  function render(){
    const rect = document.getElementById('stage').getBoundingClientRect();
    const wScale = Math.floor(rect.width/(COLS*SIZE));
    const hScale = Math.floor(rect.height/(ROWS*SIZE));
    const scale = Math.max(1, Math.min(wScale, hScale));
    const cssW = COLS*SIZE*scale, cssH = ROWS*SIZE*scale;
    const style = canvas.style;
    style.width = cssW+'px'; style.height = cssH+'px';

    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      const t = board[y][x];
      drawCell(ctx, x*SIZE, y*SIZE, SIZE, t? COLORS[t] : COLORS.X);
    }
    if(current){
      const m=current.m, color=COLORS[current.t];
      for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){
        if(m[y][x]) drawCell(ctx, (current.x+x)*SIZE, (current.y+y)*SIZE, SIZE, color);
      }
    }
  }

  function loop(ts){
    try{
      const dt = ts - lastTime; lastTime = ts;
      update(dt);
      dbgEl.textContent = 'dt:'+Math.round(dt)+'ms  level:'+level+'  running:'+(running?1:0);
    }catch(e){
      toast('루프 에러: '+e.message);
    }
    requestAnimationFrame(loop);
  }

  function startGame(){
    if(current==null){ spawn(); }
    running = true;
    requestAnimationFrame(loop);
  }

  function gameOver(){
    running=false;
    toast('Game Over');
    resetGame(true);
  }

  function resetGame(keepOverlay){
    board = makeBoard();
    current = null;
    nextType = pickType();
    dropInterval = gravityMsForLevel(level=0);
    lastTime = 0; acc=0;
    lines=0;
    if(!keepOverlay){ overlay.classList.remove('hidden'); }
  }

  function gravityMsForLevel(lv){ const frames = GFRAMES[Math.min(29, lv)] ?? 48; return Math.max(16, frames*(1000/60)); }
  function drawNext(){} // omitted mini preview to keep file shorter
})();
</script>
</body>
</html>
