<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<title>Tetris (NES ë£°) + BGM v4.9.1 [Tap-Queue]</title>
<style>
  :root { --bg:#0f1115; --panel:rgba(255,255,255,0.06); --accent:#7dd3fc; --btn:#1f2937; --btnBorder:rgba(255,255,255,.18); }
  html, body { margin:0; padding:0; height:100%; background:linear-gradient(180deg,#0f1115,#0b0d11); color:#e5e7eb; font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,Arial,sans-serif; overscroll-behavior: none; }
  .wrap { max-width:1100px; margin:0 auto; padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; padding-bottom: calc(90px + env(safe-area-inset-bottom)); }
  @media (min-width: 950px){ .wrap { grid-template-columns: 0.9fr 1.1fr; padding-bottom: 10px; } }
  .card { background: var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
  #stage { position:relative; display:flex; justify-content:center; align-items:center; min-height:60vh; touch-action:none; overscroll-behavior: contain; }
  #game { background:#111; border:1px solid rgba(255,255,255,.1); border-radius:8px; image-rendering: pixelated; outline:none; touch-action:none; }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); border-radius:10px; }
  #overlay.hidden { display:none; }
  #overlay .box { text-align:center; }
  .btn { background:var(--btn); color:#fff; border:1px solid var(--btnBorder); border-radius:12px; padding:10px 12px; cursor:pointer; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  #stats { display:grid; grid-template-columns: repeat(2,minmax(0,1fr)); gap:8px; }
  .stat { background:rgba(0,0,0,0.35); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.08); }
  .strong { font-weight:800; color:#fff; }
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .note { font-size:12px; color:#cbd5e1; }
  .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:6px 0; }
  .sep { width:1px; height:20px; background:rgba(255,255,255,.15); display:inline-block; }
  input[type="number"] { width:80px; }
  label small { opacity:.8; }
  #err { position:fixed; left:10px; bottom:10px; background:#c00; color:#fff; padding:8px 10px; border-radius:8px; font-size:12px; z-index:9999; white-space:pre-wrap; display:none; }
  #dbg { position:fixed; right:10px; bottom:10px; font-size:11px; color:#9ca3af; white-space:pre; background:rgba(0,0,0,.35); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.15); }
  #mobileControls {
    position: fixed; left: 0; right: 0; bottom: 0;
    padding: 8px calc(12px + env(safe-area-inset-right)) calc(10px + env(safe-area-inset-bottom)) calc(12px + env(safe-area-inset-left));
    display: flex; justify-content: space-between; align-items: flex-end;
    z-index: 999; pointer-events: none;
  }
  .cluster { display:flex; gap:10px; pointer-events: auto; }
  .mbtn { background: var(--btn); border: 1px solid var(--btnBorder); color: #fff; border-radius:16px;
           display:flex; align-items:center; justify-content:center; width:64px; height:64px; font-size:22px;
           box-shadow: 0 6px 20px rgba(0,0,0,0.35); touch-action:manipulation;
           -webkit-user-select:none; user-select:none; }
  .mbtn:active { transform: translateY(1px); }
  .hidden { display:none !important; }
  .muted { opacity:.55; pointer-events:none; }
</style>
</head>
<body>
<div id="err"></div>
<div id="dbg"></div>
<div class="wrap">
  <div class="card" id="stage">
    <canvas id="game" width="320" height="640" tabindex="0"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 style="margin:0 0 10px 0;">Tetris (NES) + BGM</h2>
        <p class="note">ì‹œì‘ì„ ëˆ„ë¥´ë©´ ì˜¤ë””ì˜¤ ê¶Œí•œì´ í™œì„±í™”ë˜ê³  BGMì´ ì¬ìƒë©ë‹ˆë‹¤.</p>
        <button id="startBtn" class="btn">â–¶ ì‹œì‘</button>
      </div>
    </div>
    <audio id="bgmAudio" preload="auto"></audio>
  </div>
  <div class="card">
    <div class="controls">
      <div class="row">
        <button id="btnPause" class="btn">â¸ ì¼ì‹œì •ì§€</button>
        <button id="btnReset" class="btn">â†º ë¦¬ì…‹</button>
        <span class="sep"></span>
        <label>íŠ¸ë™: 
          <select id="trackSel">
            <option value="A" selected>A</option>
            <option value="B">B</option>
            <option value="C">C</option>
          </select>
        </label>
        <label>ğŸµ BGM <input type="checkbox" id="bgmToggle" checked></label>
        <label>ë³¼ë¥¨ <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px;"></label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="cycleABC" checked> ABC ìë™ ìˆœí™˜</label>
        <span class="sep"></span>
        <span id="loopRow">
          <label>Loop ì‚¬ìš© <input type="checkbox" id="loopEnable"></label>
          <label>ì‹œì‘(s) <input type="number" id="loopStart" value="0" step="0.1"></label>
          <label>ë(s) <input type="number" id="loopEnd" value="9999" step="0.1"></label>
          <button id="setStart" class="btn">í˜„ì¬â†’ì‹œì‘</button>
          <button id="setEnd" class="btn">í˜„ì¬â†’ë</button>
        </span>
      </div>
      <div class="row">
        <label>Fade In(s) <input type="number" id="fadeIn" value="1.0" min="0" max="10" step="0.1"></label>
        <label>Fade Out(s) <input type="number" id="fadeOut" value="0.6" min="0" max="10" step="0.1"></label>
        <button id="testFade" class="btn">í˜ì´ë“œ í…ŒìŠ¤íŠ¸</button>
      </div>
      <div class="row">
        <label><input type="checkbox" id="lockKeys" checked> í‚¤ ì…ë ¥ì„ ê²Œì„ì— ê³ ì •</label>
        <label><input type="checkbox" id="enableHardDrop"> Space=í•˜ë“œë“œë¡­(ì˜µì…˜)</label>
        <span class="sep"></span>
        <label>DAS(ms) <input type="number" id="dasMs" value="130" min="0" max="500" step="10"></label>
        <label>ARR(ms) <input type="number" id="arrMs" value="50" min="0" max="200" step="5"></label>
        <label>Soft(ms) <input type="number" id="softMs" value="50" min="0" max="200" step="5"></label>
      </div>
    </div>
  </div>
</div>

<!-- Mobile Controls (fixed bottom) -->
<div id="mobileControls">
  <div class="cluster left">
    <div class="mbtn" id="mLeft" title="Left">â—€</div>
    <div class="mbtn" id="mRight" title="Right">â–¶</div>
  </div>
  <div class="cluster right">
    <div class="mbtn" id="mRotate" title="Rotate">âŸ³</div>
    <div class="mbtn" id="mSoft" title="Soft Drop">â†“</div>
    <div class="mbtn" id="mHard" title="Hard Drop">â¤“</div>
  </div>
</div>

<script>
(function(){
  var errEl = document.getElementById('err');
  var dbgEl = document.getElementById('dbg');
  function toast(msg){ try{ errEl.style.display='block'; errEl.textContent=msg; setTimeout(()=>{ errEl.style.display='none'; }, 4000);}catch(e){} }
  window.addEventListener('error', e => toast('ì—ëŸ¬: ' + (e.message||e.toString())));
  window.addEventListener('unhandledrejection', e => toast('Promise ì—ëŸ¬: ' + ((e.reason&&(e.reason.message||e.reason.toString()))||'unknown')));

  // ====== BGM (same) ======
  const TRACKS = { A:'bgm_A.mp3', B:'bgm_B.mp3', C:'bgm_C.mp3' };
  const order = ['A','B','C'];
  const bgmEl = document.getElementById('bgmAudio');
  const trackSel = document.getElementById('trackSel');
  const bgmToggle = document.getElementById('bgmToggle');
  const bgmVol = document.getElementById('bgmVol');
  const cycleToggle = document.getElementById('cycleABC');
  const loopRow = document.getElementById('loopRow');
  const loopEnable = document.getElementById('loopEnable');
  const loopStartEl = document.getElementById('loopStart');
  const loopEndEl = document.getElementById('loopEnd');
  const setStartBtn = document.getElementById('setStart');
  const setEndBtn = document.getElementById('setEnd');
  const fadeInEl = document.getElementById('fadeIn');
  const fadeOutEl = document.getElementById('fadeOut');
  const testFadeBtn = document.getElementById('testFade');

  let audioCtx = null, srcNode = null, volGain = null, fadeGain = null;
  let loopStart = 0, loopEnd = 9999, loopOn = false;
  let userVol = parseFloat(bgmVol.value);

  async function initAudio(){
    if(audioCtx) return true;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();
      srcNode = audioCtx.createMediaElementSource(bgmEl);
      volGain = audioCtx.createGain();
      fadeGain = audioCtx.createGain();
      volGain.gain.value = userVol;
      fadeGain.gain.value = 0.0;
      srcNode.connect(volGain).connect(fadeGain).connect(audioCtx.destination);
      return true;
    }catch(e){
      toast('ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì‹¤íŒ¨: '+e.message);
      bgmToggle.checked = false;
      return false;
    }
  }
  function fadeTo(target, dur){ if(!audioCtx||!fadeGain) return; const g=fadeGain.gain, now=audioCtx.currentTime; try{ g.setValueAtTime(g.value,now); g.linearRampToValueAtTime(target, now+Math.max(0,dur||0)); }catch{} }
  function applyLoopInputs(){ loopOn=!!loopEnable.checked; loopStart=parseFloat(loopStartEl.value)||0; loopEnd=parseFloat(loopEndEl.value)||9999; if(loopEnd<=loopStart+0.05){loopOn=false;} updateLoopFlags(); }
  function updateLoopFlags(){ if(cycleToggle.checked){ bgmEl.loop=false; } else { bgmEl.loop=!loopOn; } loopRow.classList.toggle('muted', cycleToggle.checked); }
  function setTrack(name){ const url=TRACKS[name]||TRACKS.A; const was=!bgmEl.paused; const out=parseFloat(fadeOutEl.value)||0, inn=parseFloat(fadeInEl.value)||0; if(was) fadeTo(0.0,out); const swap=()=>{ bgmEl.pause(); bgmEl.src=url; bgmEl.currentTime=loopStart||0; bgmEl.load(); if(bgmToggle.checked){ bgmEl.play().then(()=>fadeTo(1.0,inn)).catch(()=>{});} }; if(was&&out>0) setTimeout(swap,out*1000); else swap(); }
  function nextTrack(){ const cur=trackSel.value; const idx=order.indexOf(cur); const n=order[(idx+1)%order.length]; trackSel.value=n; setTrack(n); }
  bgmEl.addEventListener('error', ()=> toast('BGM ë¡œë“œ ì‹¤íŒ¨: '+(bgmEl.src||'')) );
  bgmEl.addEventListener('ended', ()=>{ if(cycleToggle.checked) nextTrack(); });
  bgmEl.addEventListener('timeupdate', ()=>{ if(cycleToggle.checked) return; if(!loopOn) return; if(bgmEl.currentTime>=loopEnd-0.02){ bgmEl.currentTime=loopStart; if(bgmEl.paused && bgmToggle.checked){ bgmEl.play().catch(()=>{}); } } });
  bgmVol.addEventListener('input', ()=>{ userVol=parseFloat(bgmVol.value)||0; if(volGain) volGain.gain.value=userVol; });
  bgmToggle.addEventListener('change', ()=>{ if(!audioCtx) return; if(bgmToggle.checked){ const inn=parseFloat(fadeInEl.value)||0; bgmEl.play().then(()=>fadeTo(1.0,inn)).catch(()=>{});} else { const out=parseFloat(fadeOutEl.value)||0; fadeTo(0.0,out); setTimeout(()=>bgmEl.pause(), out*1000);} });
  trackSel.addEventListener('change', ()=> setTrack(trackSel.value));
  testFadeBtn.addEventListener('click', ()=>{ const out=parseFloat(fadeOutEl.value)||0, inn=parseFloat(fadeInEl.value)||0; fadeTo(0.0,out); setTimeout(()=>{ if(bgmEl.paused) bgmEl.play().catch(()=>{}); fadeTo(1.0,inn); }, Math.max(1,out*1000+200)); });
  cycleToggle.addEventListener('change', ()=> applyLoopInputs());
  loopEnable.addEventListener('change', applyLoopInputs);
  loopStartEl.addEventListener('input', applyLoopInputs);
  loopEndEl.addEventListener('input', applyLoopInputs);
  setStartBtn.addEventListener('click', ()=>{ loopStartEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });
  setEndBtn.addEventListener('click', ()=>{ loopEndEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });

  // ====== Game (tap-queue + state-driven hold) ======
  const COLS=10, ROWS=20, SIZE=32;
  const COLORS={ I:'#67e8f9', J:'#60a5fa', L:'#f59e0b', O:'#fef08a', S:'#34d399', T:'#c084fc', Z:'#f87171', X:'#0b0d12' };
  const SHAPES={
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0],[1,1,1],[0,0,0]],
    L:[[0,0,1],[1,1,1],[0,0,0]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]],
    T:[[0,1,0],[1,1,1],[0,0,0]]
  };
  const TYPES=['I','J','L','O','S','T','Z'];
  let prevType=null; function pickType(){ const roll=()=>TYPES[(Math.random()*TYPES.length)|0]; let t=roll(); if(prevType&&t===prevType) t=roll(); prevType=t; return t; }
  const GFRAMES={ 0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1 };
  function gravityMsForLevel(lv){ const frames=GFRAMES[Math.min(29,lv)] ?? 48; return Math.max(16, frames*(1000/60)); }

  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
  let board=makeBoard(); let current=null; let nextType=pickType(); let dropInterval=gravityMsForLevel(0); let lastTime=0; let acc=0; let running=false; let lines=0, level=0;

  // Input state & timing
  const dasEl=document.getElementById('dasMs'), arrEl=document.getElementById('arrMs'), softEl=document.getElementById('softMs');
  let dasMs=parseFloat(dasEl.value)||130, arrMs=parseFloat(arrEl.value)||50, softMs=parseFloat(softEl.value)||50;
  dasEl.addEventListener('input', ()=> dasMs=Math.max(0,parseFloat(dasEl.value)||0));
  arrEl.addEventListener('input', ()=> arrMs=Math.max(0,parseFloat(arrEl.value)||0));
  softEl.addEventListener('input', ()=> softMs=Math.max(0,parseFloat(softEl.value)||0));

  const input={ left:false, right:false, down:false };
  const taps={ left:0, right:0 }; // queued discrete taps
  let hDir=null; // 'L'|'R'|null
  let nextHMoveAt=0, nextSoftAt=0;

  function setLeft(v){ if(v){ input.left=true; input.right=false; } else input.left=false; }
  function setRight(v){ if(v){ input.right=true; input.left=false; } else input.right=false; }
  function setDown(v){ input.down=!!v; }

  // Bind mobile buttons
  function bindHold(btn, onPress, onRelease){
    btn.addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); try{ btn.setPointerCapture(e.pointerId);}catch{} onPress(); });
    ['pointerup','pointercancel','pointerleave'].forEach(ev=> btn.addEventListener(ev, e=>{ e.preventDefault(); onRelease&&onRelease(); }));
    btn.addEventListener('contextmenu', e=> e.preventDefault());
  }
  bindHold(document.getElementById('mLeft'), ()=>{ taps.left++; setLeft(true); }, ()=> setLeft(false));
  bindHold(document.getElementById('mRight'), ()=>{ taps.right++; setRight(true); }, ()=> setRight(false));
  bindHold(document.getElementById('mSoft'), ()=> setDown(true), ()=> setDown(false));
  document.getElementById('mRotate').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); rotate(); });
  document.getElementById('mHard').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); hardDrop(); });

  // Keyboard
  const lockKeysEl=document.getElementById('lockKeys');
  const enableHardDropEl=document.getElementById('enableHardDrop');
  window.addEventListener('keydown', (e)=>{
    const k=e.key; const isGameKey=(k==='ArrowLeft'||k==='ArrowRight'||k==='ArrowDown'||k==='ArrowUp'||k==='x'||k==='X'||k===' '||k==='p'||k==='P'||k==='r'||k==='R');
    if(!isGameKey) return;
    if(lockKeysEl.checked){ e.preventDefault(); e.stopPropagation(); }
    if(k==='ArrowLeft'){ taps.left++; setLeft(true); }
    else if(k==='ArrowRight'){ taps.right++; setRight(true); }
    else if(k==='ArrowDown'){ setDown(true); }
    else if(k==='ArrowUp'||k==='x'||k==='X'){ rotate(); }
    else if(k===' ' && enableHardDropEl.checked){ hardDrop(); }
    else if(k==='p'||k==='P'){ running=!running; }
    else if(k==='r'||k==='R'){ resetGame(); }
  }, true);
  window.addEventListener('keyup', (e)=>{ const k=e.key; if(k==='ArrowLeft') setLeft(false); else if(k==='ArrowRight') setRight(false); else if(k==='ArrowDown') setDown(false); }, true);

  // Start / Pause / Reset
  const overlay=document.getElementById('overlay');
  document.getElementById('startBtn').addEventListener('click', async ()=>{
    const ok=await initAudio(); applyLoopInputs(); setTrack(trackSel.value); if(ok) fadeTo(1.0, parseFloat(fadeInEl.value)||0);
    overlay.classList.add('hidden'); focusGame(); startGame();
  });
  document.getElementById('btnPause').addEventListener('click', ()=>{ running=!running; if(running) focusGame(); });
  document.getElementById('btnReset').addEventListener('click', ()=>{ resetGame(); focusGame(); });

  function focusGame(){ canvas.focus({preventScroll:true}); }
  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++) b[r]=new Array(COLS).fill(null); return b; }
  function clone(m){ return m.map(row=>row.slice()); }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--) row.push(m[y][x]); out.push(row);} return out; }
  function getShape(t){ return clone(SHAPES[t]); }

  function spawn(){ const t=nextType; nextType=pickType(); current={ t, m:getShape(t), x:(COLS/2|0)-2, y:-2 }; if(collides(current,current.x,current.y)){ gameOver(); } }
  function collides(piece,nx,ny,nm){ const m=nm||piece.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=nx+x, by=ny+y; if(bx<0||bx>=COLS||by>=ROWS) return true; if(by>=0 && board[by][bx]) return true; } return false; }
  function tryMove(dx,dy){ const nx=current.x+dx, ny=current.y+dy; if(!collides(current,nx,ny)){ current.x=nx; current.y=ny; return true; } return false; }
  function rotate(){ let nm=rotateCW(current.m); if(!collides(current,current.x,current.y,nm)) current.m=nm; }
  function softStep(){ if(!tryMove(0,1)) lock(); }
  function hardDrop(){ while(tryMove(0,1)){} lock(); }
  function lock(){ const m=current.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=current.x+x, by=current.y+y; if(by>=0) board[by][bx]=current.t; } clearLines(); spawn(); }
  function clearLines(){ let cleared=0; for(let r=ROWS-1;r>=0;r--){ if(board[r].every(v=>!!v)){ board.splice(r,1); board.unshift(new Array(COLS).fill(null)); cleared++; r++; } } if(cleared>0){ lines+=cleared; if(lines>=(level+1)*10){ level++; dropInterval=gravityMsForLevel(level); } } }

  function handleHorizontal(now){
    // 1) Consume taps (guaranteed single steps)
    if(taps.left>0){ if(tryMove(-1,0)){} taps.left=0; hDir = 'L'; nextHMoveAt = now + dasMs; }
    else if(taps.right>0){ if(tryMove(1,0)){} taps.right=0; hDir = 'R'; nextHMoveAt = now + dasMs; }
    // 2) Handle holds
    const want = input.left ? 'L' : input.right ? 'R' : null;
    if(!want){ hDir=null; return; }
    if(want !== hDir){ hDir = want; tryMove(hDir==='L'?-1:1); nextHMoveAt = now + dasMs; return; }
    while(now >= nextHMoveAt){
      if(!tryMove(hDir==='L'?-1:1)) break;
      nextHMoveAt += arrMs;
      if(arrMs <= 0) break;
    }
  }

  function handleSoft(now){
    if(!input.down){ nextSoftAt = now + softMs; return; }
    while(now >= nextSoftAt){
      if(!tryMove(0,1)){ lock(); break; }
      nextSoftAt += softMs;
      if(softMs <= 0) break;
    }
  }

  function update(dt){
    if(!running){ return; }
    if(!current){ spawn(); } // safety
    acc += dt;
    const now = performance.now();
    handleHorizontal(now);
    handleSoft(now);
    if(acc >= dropInterval){ if(!input.down){ if(!tryMove(0,1)) lock(); } acc = 0; }
  }

  function drawCell(c,x,y,s,color){ c.fillStyle=color; c.fillRect(x,y,s,s); c.strokeStyle='rgba(0,0,0,0.35)'; c.lineWidth=2; c.strokeRect(x+1,y+1,s-2,s-2); c.strokeStyle='rgba(255,255,255,0.12)'; c.lineWidth=2; c.strokeRect(x+0.5,y+0.5,s-1,s-1); }
  function render(){
    const rect=document.getElementById('stage').getBoundingClientRect();
    const wScale=Math.floor(rect.width/(COLS*SIZE)), hScale=Math.floor(rect.height/(ROWS*SIZE)), scale=Math.max(1, Math.min(wScale,hScale));
    canvas.style.width=(COLS*SIZE*scale)+'px'; canvas.style.height=(ROWS*SIZE*scale)+'px';
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // grid
    ctx.strokeStyle='rgba(255,255,255,0.04)';
    for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*SIZE+0.5); ctx.lineTo(COLS*SIZE,y*SIZE+0.5); ctx.stroke(); }
    for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*SIZE+0.5,0); ctx.lineTo(x*SIZE+0.5,ROWS*SIZE); ctx.stroke(); }
    // cells
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=board[y][x]; drawCell(ctx,x*SIZE,y*SIZE,SIZE,t?COLORS[t]:COLORS.X); }
    if(current){ const m=current.m, color=COLORS[current.t]; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(m[y][x]) drawCell(ctx,(current.x+x)*SIZE,(current.y+y)*SIZE,SIZE,color); } }
    dbgEl.textContent = JSON.stringify({ x: current?current.x:null, y: current?current.y:null, hDir, tapsL:taps.left, tapsR:taps.right, left:input.left, right:input.right, down:input.down });
  }

  function loop(ts){ try{ const dt=ts-lastTime; lastTime=ts; update(dt); render(); }catch(e){ toast('ë£¨í”„ ì—ëŸ¬: '+e.message); } requestAnimationFrame(loop); }

  function startGame(){ if(current==null) spawn(); running=true; requestAnimationFrame(loop); }
  function gameOver(){ running=false; toast('Game Over'); resetGame(true); }
  function resetGame(keepOverlay){ board=makeBoard(); current=null; nextType=pickType(); dropInterval=gravityMsForLevel(level=0); lastTime=0; acc=0; lines=0; if(!keepOverlay){ overlay.classList.remove('hidden'); } }

  // Double-tap zoom suppression (soft)
  ;['stage','mobileControls'].forEach(id=>{ const el=document.getElementById(id); if(!el) return;
    el.addEventListener('dblclick', e=> e.preventDefault(), {passive:false});
    let last=0; el.addEventListener('touchend', e=>{ const now=Date.now(); if(now-last<320){ e.preventDefault(); } last=now; }, {passive:false});
  });
})();
</script>
</body>
</html>
