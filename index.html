<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Tetris (NES ë£°) + BGM v4.9.5 [iOS zoom fix]</title>
<style>
  :root { --bg:#0f1115; --panel:rgba(255,255,255,0.06); --accent:#7dd3fc; --btn:#1f2937; --btnBorder:rgba(255,255,255,.18); }
  html, body { margin:0; padding:0; height:100%; background:linear-gradient(180deg,#0f1115,#0b0d11); color:#e5e7eb; font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,Arial,sans-serif; overscroll-behavior: none; -webkit-text-size-adjust: 100%; }
  .wrap { max-width:1100px; margin:0 auto; padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; padding-bottom: calc(90px + env(safe-area-inset-bottom)); }
  @media (min-width: 950px){ .wrap { grid-template-columns: 0.9fr 1.1fr; padding-bottom: 10px; } }
  .card { background: var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
  #stage { position:relative; display:flex; justify-content:center; align-items:center; min-height:60vh; touch-action:none; overscroll-behavior: contain; }
  #game { background:#111; border:1px solid rgba(255,255,255,.1); border-radius:8px; image-rendering: pixelated; outline:none; touch-action:none; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: rgba(0,0,0,0); }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); border-radius:10px; z-index:1500; }
  #overlay.hidden { display:none; }
  #overlay .box { text-align:center; }
  .btn { background:var(--btn); color:#fff; border:1px solid var(--btnBorder); border-radius:12px; padding:10px 12px; cursor:pointer; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }
  #dbg { position:fixed; right:10px; bottom:110px; font-size:11px; color:#e5e7eb; white-space:pre; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.15); z-index:1400; 
         backdrop-filter: blur(2px); max-width:80vw; }
  #dbg.top { left:10px; top:10px; right:auto; bottom:auto; }
  #dbg::after { content:' íƒ­í•˜ë©´ ë³µì‚¬ '; font-size:10px; opacity:.7; }
  #mobileControls {
    position: fixed; left: 0; right: 0; bottom: 0;
    padding: 8px calc(12px + env(safe-area-inset-right)) calc(10px + env(safe-area-inset-bottom)) calc(12px + env(safe-area-inset-left));
    display: flex; justify-content: space-between; align-items: flex-end;
    z-index: 999; pointer-events: none;
  }
  .cluster { display:flex; gap:10px; pointer-events: auto; }
  .mbtn { background: var(--btn); border: 1px solid var(--btnBorder); color: #fff; border-radius:16px;
           display:flex; align-items:center; justify-content:center; width:64px; height:64px; font-size:22px;
           box-shadow: 0 6px 20px rgba(0,0,0,0.35); touch-action:none;  /* stronger than manipulation */
           -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: rgba(0,0,0,0); }
  .mbtn:active { transform: translateY(1px); }
  .hidden { display:none !important; }
  .muted { opacity:.55; pointer-events:none; }
  #startFab {
    position: fixed; right: 12px; top: 12px; z-index: 1600;
    background: #16a34a; color: #fff; border: none; border-radius: 9999px;
    padding: 10px 14px; font-size: 14px; box-shadow: 0 8px 24px rgba(0,0,0,.35);
  }
</style>
</head>
<body>
<button id="startFab" title="ì‹œì‘ì´ ì•ˆ ëˆŒë¦¬ë©´ ì´ê±¸ íƒ­í•˜ì„¸ìš”">â–¶ ì‹œì‘</button>
<div id="dbg"></div>
<div class="wrap">
  <div class="card" id="stage">
    <canvas id="game" width="320" height="640" tabindex="0"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 style="margin:0 0 10px 0;">Tetris (NES) + BGM</h2>
        <p class="note">ì‹œì‘ì„ ëˆ„ë¥´ë©´ ì˜¤ë””ì˜¤ ê¶Œí•œì´ í™œì„±í™”ë˜ê³  BGMì´ ì¬ìƒë©ë‹ˆë‹¤.</p>
        <div style="display:flex; gap:8px; justify-content:center;">
          <button id="startBtn" class="btn" onclick="window.__startGameFromUI&&window.__startGameFromUI(true)">â–¶ ì‹œì‘</button>
          <button id="startNoAudioBtn" class="btn" onclick="window.__startGameFromUI&&window.__startGameFromUI(false)">ìŒì•… ì—†ì´ ì‹œì‘</button>
        </div>
      </div>
    </div>
    <audio id="bgmAudio" preload="auto"></audio>
  </div>
  <div class="card">
    <div class="controls">
      <div class="row">
        <button id="btnPause" class="btn">â¸ ì¼ì‹œì •ì§€</button>
        <button id="btnReset" class="btn">â†º ë¦¬ì…‹</button>
        <span class="sep"></span>
        <label>íŠ¸ë™: 
          <select id="trackSel">
            <option value="A" selected>A</option>
            <option value="B">B</option>
            <option value="C">C</option>
          </select>
        </label>
        <label>ğŸµ BGM <input type="checkbox" id="bgmToggle" checked></label>
        <label>ë³¼ë¥¨ <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px;"></label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="cycleABC" checked> ABC ìë™ ìˆœí™˜</label>
        <span class="sep"></span>
        <span id="loopRow">
          <label>Loop ì‚¬ìš© <input type="checkbox" id="loopEnable"></label>
          <label>ì‹œì‘(s) <input type="number" id="loopStart" value="0" step="0.1"></label>
          <label>ë(s) <input type="number" id="loopEnd" value="9999" step="0.1"></label>
          <button id="setStart" class="btn">í˜„ì¬â†’ì‹œì‘</button>
          <button id="setEnd" class="btn">í˜„ì¬â†’ë</button>
        </span>
      </div>
      <div class="row">
        <label>Fade In(s) <input type="number" id="fadeIn" value="1.0" min="0" max="10" step="0.1"></label>
        <label>Fade Out(s) <input type="number" id="fadeOut" value="0.6" min="0" max="10" step="0.1"></label>
        <button id="testFade" class="btn">í˜ì´ë“œ í…ŒìŠ¤íŠ¸</button>
      </div>
      <div class="row">
        <label><input type="checkbox" id="lockKeys" checked> í‚¤ ì…ë ¥ì„ ê²Œì„ì— ê³ ì •</label>
        <label><input type="checkbox" id="enableHardDrop"> Space=í•˜ë“œë“œë¡­(ì˜µì…˜)</label>
        <span class="sep"></span>
        <label>DAS(ms) <input type="number" id="dasMs" value="130" min="0" max="500" step="10"></label>
        <label>ARR(ms) <input type="number" id="arrMs" value="50" min="0" max="200" step="5"></label>
        <label>Soft(ms) <input type="number" id="softMs" value="50" min="0" max="200" step="5"></label>
      </div>
    </div>
  </div>
</div>

<!-- Mobile Controls (fixed bottom) -->
<div id="mobileControls">
  <div class="cluster left">
    <div class="mbtn" id="mLeft" title="Left">â—€</div>
    <div class="mbtn" id="mRight" title="Right">â–¶</div>
  </div>
  <div class="cluster right">
    <div class="mbtn" id="mRotate" title="Rotate">âŸ³</div>
    <div class="mbtn" id="mSoft" title="Soft Drop">â†“</div>
    <div class="mbtn" id="mHard" title="Hard Drop">â¤“</div>
  </div>
</div>

<script>
(function(){
  const dbgEl = document.getElementById('dbg');
  const overlay = document.getElementById('overlay');
  const startFab = document.getElementById('startFab');
  function dbg(o){ try{ dbgEl.textContent = JSON.stringify(o); }catch{} }

  // ---- Global doubleâ€‘tap & pinch zoom blocker (strict for iOS) ----
  (function installZoomBlocker(){
    let lastTouch = 0;
    const blockDbl = (e)=>{
      const now = Date.now();
      if(now - lastTouch < 350){
        e.preventDefault(); e.stopPropagation();
      }
      lastTouch = now;
    };
    const blockAll = (e)=>{ e.preventDefault(); e.stopPropagation(); };
    // Capture phase to beat default handlers
    ['dblclick'].forEach(ev => document.addEventListener(ev, blockAll, {passive:false, capture:true}));
    ['touchend'].forEach(ev => document.addEventListener(ev, blockDbl, {passive:false, capture:true}));
    ['gesturestart','gesturechange','gestureend'].forEach(ev => document.addEventListener(ev, blockAll, {passive:false, capture:true}));
  })();

  // --- Debug copy & move ---
  let dbgPosTop = window.matchMedia('(max-width: 950px)').matches;
  if(dbgPosTop) dbgEl.classList.add('top');
  function copyDbg(){
    const t = dbgEl.textContent; if(!t) return;
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(t).then(()=>flash('ë””ë²„ê·¸ ë³µì‚¬ë¨')).catch(()=>fallbackCopy(t));
    }else fallbackCopy(t);
  }
  function fallbackCopy(t){ const ta=document.createElement('textarea'); ta.value=t; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); flash('ë””ë²„ê·¸ ë³µì‚¬ë¨ (fallback)'); }
  function flash(msg){ const div=document.createElement('div'); div.textContent=msg; div.style.cssText='position:fixed; top:12px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,.7); color:#fff; padding:6px 10px; border-radius:8px; z-index:2000;'; document.body.appendChild(div); setTimeout(()=>div.remove(),1200); }
  dbgEl.addEventListener('click', e=>{ e.preventDefault(); e.stopPropagation(); copyDbg(); });
  let lastTap=0; dbgEl.addEventListener('touchend', e=>{ const now=Date.now(); if(now-lastTap<300){ dbgPosTop=!dbgPosTop; dbgEl.classList.toggle('top', dbgPosTop); } lastTap=now; }, {passive:false});

  // ====== BGM & Game â€“ same as 4.9.4 ======
  const TRACKS = { A:'bgm_A.mp3', B:'bgm_B.mp3', C:'bgm_C.mp3' };
  const order = ['A','B','C'];
  const bgmEl = document.getElementById('bgmAudio');
  const trackSel = document.getElementById('trackSel');
  const bgmToggle = document.getElementById('bgmToggle');
  const bgmVol = document.getElementById('bgmVol');
  const cycleToggle = document.getElementById('cycleABC');
  const loopRow = document.getElementById('loopRow');
  const loopEnable = document.getElementById('loopEnable');
  const loopStartEl = document.getElementById('loopStart');
  const loopEndEl = document.getElementById('loopEnd');
  const setStartBtn = document.getElementById('setStart');
  const setEndBtn = document.getElementById('setEnd');
  const fadeInEl = document.getElementById('fadeIn');
  const fadeOutEl = document.getElementById('fadeOut');
  const testFadeBtn = document.getElementById('testFade');

  let audioCtx=null, srcNode=null, volGain=null, fadeGain=null;
  let loopStart=0, loopEnd=9999, loopOn=false;
  let userVol=parseFloat(bgmVol.value);

  async function initAudio(){
    if(audioCtx) return true;
    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      await audioCtx.resume();
      srcNode = audioCtx.createMediaElementSource(bgmEl);
      volGain = audioCtx.createGain();
      fadeGain = audioCtx.createGain();
      volGain.gain.value = userVol;
      fadeGain.gain.value = 0.0;
      srcNode.connect(volGain).connect(fadeGain).connect(audioCtx.destination);
      return true;
    }catch(e){ console.warn('ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì‹¤íŒ¨', e); return false; }
  }
  function fadeTo(target,dur){ if(!audioCtx||!fadeGain) return; const g=fadeGain.gain, now=audioCtx.currentTime; try{ g.setValueAtTime(g.value,now); g.linearRampToValueAtTime(target, now+Math.max(0,dur||0)); }catch{} }
  function applyLoopInputs(){ loopOn=!!loopEnable.checked; loopStart=parseFloat(loopStartEl.value)||0; loopEnd=parseFloat(loopEndEl.value)||9999; if(loopEnd<=loopStart+0.05){ loopOn=false; } loopRow.classList.toggle('muted', cycleToggle.checked); bgmEl.loop = cycleToggle.checked? false : !loopOn; }
  function setTrack(name){ const url=TRACKS[name]||TRACKS.A; const was=!bgmEl.paused; const out=parseFloat(fadeOutEl.value)||0, inn=parseFloat(fadeInEl.value)||0; if(was) fadeTo(0.0,out); const swap=()=>{ bgmEl.pause(); bgmEl.src=url; bgmEl.currentTime=loopStart||0; bgmEl.load(); if(bgmToggle.checked){ bgmEl.play().then(()=>fadeTo(1.0,inn)).catch(()=>{});} }; if(was&&out>0) setTimeout(swap,out*1000); else swap(); }
  function nextTrack(){ const cur=trackSel.value; const idx=order.indexOf(cur); const n=order[(idx+1)%order.length]; trackSel.value=n; setTrack(n); }
  cycleToggle.addEventListener('change', applyLoopInputs);
  loopEnable.addEventListener('change', applyLoopInputs);
  loopStartEl.addEventListener('input', applyLoopInputs);
  loopEndEl.addEventListener('input', applyLoopInputs);
  setStartBtn.addEventListener('click', ()=>{ loopStartEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });
  setEndBtn.addEventListener('click', ()=>{ loopEndEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });

  // Game core (unchanged from 4.9.4)
  const COLS=10, ROWS=20, SIZE=32;
  const COLORS={ I:'#67e8f9', J:'#60a5fa', L:'#f59e0b', O:'#fef08a', S:'#34d399', T:'#c084fc', Z:'#f87171', X:'#0b0d12' };
  const SHAPES={ I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0],[0,0,0]], Z:[[1,1,0],[0,1,1],[0,0,0]], T:[[0,1,0],[1,1,1],[0,0,0]] };
  const TYPES=['I','J','L','O','S','T','Z'];
  let prevType=null; function pickType(){ const roll=()=>TYPES[(Math.random()*TYPES.length)|0]; let t=roll(); if(prevType&&t===prevType) t=roll(); prevType=t; return t; }
  const GFRAMES={ 0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1 };
  function gravityMsForLevel(lv){ const frames=GFRAMES[Math.min(29,lv)] ?? 48; return Math.max(16, frames*(1000/60)); }

  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
  let board=makeBoard(); let current=null; let nextType=pickType(); let dropInterval=gravityMsForLevel(0); let lastTime=0; let acc=0; let running=false; let lines=0, level=0;
  const dasEl=document.getElementById('dasMs'), arrEl=document.getElementById('arrMs'), softEl=document.getElementById('softMs');
  let dasMs=parseFloat(dasEl.value)||130, arrMs=parseFloat(arrEl.value)||50, softMs=parseFloat(softEl.value)||50;
  dasEl.addEventListener('input', ()=> dasMs=Math.max(0,parseFloat(dasEl.value)||0));
  arrEl.addEventListener('input', ()=> arrMs=Math.max(0,parseFloat(arrEl.value)||0));
  softEl.addEventListener('input', ()=> softMs=Math.max(0,parseFloat(softEl.value)||0));

  const input={ left:false, right:false, down:false };
  const taps={ left:0, right:0 };
  let hDir=null; let nextHMoveAt=0, nextSoftAt=0;
  let lastY=null, lastSoftAdvanceAt=0;

  function tryMove(dx,dy){ const nx=current.x+dx, ny=current.y+(dy||0); if(!collides(current,nx,ny)){ current.x=nx; current.y=ny; return true; } return false; }
  function collides(piece,nx,ny,nm){ const m=nm||piece.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=nx+x, by=ny+y; if(bx<0||bx>=COLS||by>=ROWS) return true; if(by>=0 && board[by][bx]) return true; } return false; }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--){ row.push(m[y][x]); } out.push(row);} return out; }
  function rotate(){ let nm=rotateCW(current.m); if(!collides(current,current.x,current.y,nm)) current.m=nm; }
  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++) b[r]=new Array(COLS).fill(null); return b; }
  function getShape(t){ return SHAPES[t].map(r=>r.slice()); }
  function spawn(){ const t=nextType; nextType=pickType(); current={ t, m:getShape(t), x:(COLS/2|0)-2, y:-2 }; lastY=current.y; if(collides(current,current.x,current.y)){ gameOver(); } }
  function hardDrop(){ while(tryMove(0,1)){} lock(); }
  function softStep(){ if(!tryMove(0,1)) lock(); }
  function lock(){ const m=current.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=current.x+x, by=current.y+y; if(by>=0) board[by][bx]=current.t; } clearLines(); spawn(); }
  function clearLines(){ let cleared=0; for(let r=ROWS-1;r>=0;r--){ if(board[r].every(v=>!!v)){ board.splice(r,1); board.unshift(new Array(COLS).fill(null)); cleared++; r++; } } if(cleared>0){ if((lines+=cleared) >= (level+1)*10){ level++; dropInterval=gravityMsForLevel(level); } } }

  function setLeft(v){ if(v){ input.left=true; input.right=false; } else input.left=false; }
  function setRight(v){ if(v){ input.right=true; input.left=false; } else input.right=false; }
  function setDown(v){ input.down=!!v; if(!v){ const now=performance.now(); nextSoftAt = now + softMs; } }

  function handleHorizontal(now){
    if(taps.left>0){ tryMove(-1,0); taps.left=0; hDir='L'; nextHMoveAt=now+dasMs; }
    else if(taps.right>0){ tryMove(1,0); taps.right=0; hDir='R'; nextHMoveAt=now+dasMs; }
    const want=input.left?'L':input.right?'R':null;
    if(!want){ hDir=null; return; }
    if(want!==hDir){ hDir=want; tryMove(hDir==='L'?-1:1,0); nextHMoveAt=now+dasMs; return; }
    while(now>=nextHMoveAt){ if(!tryMove(hDir==='L'?-1:1,0)) break; nextHMoveAt+=arrMs; if(arrMs<=0) break; }
  }
  function validTime(t){ return Number.isFinite(t) && t<=1e13; }
  function handleSoft(now){
    if(!input.down){ nextSoftAt = now + softMs; lastSoftAdvanceAt = now; return; }
    if(!validTime(nextSoftAt)){ nextSoftAt = now + softMs; }
    while(now>=nextSoftAt){
      if(!tryMove(0,1)){ lock(); lastSoftAdvanceAt = now; break; }
      lastSoftAdvanceAt = now; nextSoftAt += softMs; if(softMs<=0) break;
    }
    if(input.down){
      if(lastY===null) lastY=current.y;
      if(current.y===lastY && (now - lastSoftAdvanceAt) > Math.max(150, softMs*3)){
        if(tryMove(0,1)){ lastSoftAdvanceAt = now; nextSoftAt = now + softMs; }
      }
    }
    lastY = current.y;
  }
  function update(dt){
    if(!running){ return; }
    if(!current){ spawn(); }
    acc += dt; const now=performance.now();
    handleHorizontal(now); handleSoft(now);
    if(acc>=dropInterval){
      if(!input.down || (now - lastSoftAdvanceAt) > Math.max(300, softMs*4)){
        if(!tryMove(0,1)) lock();
      }
      acc=0;
    }
    dbg({running, y:current?current.y:null, down:input.down});
  }
  function drawCell(c,x,y,s,color){ c.fillStyle=color; c.fillRect(x,y,s,s); c.strokeStyle='rgba(0,0,0,0.35)'; c.lineWidth=2; c.strokeRect(x+1,y+1,s-2,s-2); c.strokeStyle='rgba(255,255,255,0.12)'; c.lineWidth=2; c.strokeRect(x+0.5,y+0.5,s-1,s-1); }
  function render(){ const rect=document.getElementById('stage').getBoundingClientRect(); const wScale=Math.floor(rect.width/(COLS*SIZE)), hScale=Math.floor(rect.height/(ROWS*SIZE)), scale=Math.max(1, Math.min(wScale,hScale)); canvas.style.width=(COLS*SIZE*scale)+'px'; canvas.style.height=(ROWS*SIZE*scale)+'px'; ctx.clearRect(0,0,canvas.width,canvas.height); for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=board[y][x]; drawCell(ctx,x*SIZE,y*SIZE,SIZE,t?COLORS[t]:COLORS.X); } if(current){ const m=current.m, color=COLORS[current.t]; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(m[y][x]) drawCell(ctx,(current.x+x)*SIZE,(current.y+y)*SIZE,SIZE,color); } } }
  function loop(ts){ requestAnimationFrame(loop); render(); update(ts - (window.__last||ts)); window.__last = ts; }
  function gameOver(){ running=false; resetGame(true); }
  function resetGame(keepOverlay){ board=makeBoard(); current=null; nextType=pickType(); dropInterval=gravityMsForLevel(level=0); lastTime=0; acc=0; lines=0; if(!keepOverlay){ overlay.classList.remove('hidden'); startFab.classList.remove('hidden'); } }

  async function __startGame(startAudio=true){
    if(startAudio){
      const ok = await initAudio(); applyLoopInputs(); setTrack(trackSel.value);
      if(!ok){ console.warn('ì˜¤ë””ì˜¤ ê¶Œí•œ/ì´ˆê¸°í™” ì‹¤íŒ¨ â€“ ê²Œì„ì€ ë¬´ìŒìœ¼ë¡œ ì‹œì‘'); }
    }
    overlay.classList.add('hidden'); startFab.classList.add('hidden');
    if(current==null) spawn(); running = true; requestAnimationFrame(loop); document.getElementById('game').focus({preventScroll:true});
  }
  window.__startGameFromUI = __startGame;

  document.getElementById('startBtn').addEventListener('click', ()=> __startGame(true));
  document.getElementById('startNoAudioBtn').addEventListener('click', ()=> __startGame(false));
  startFab.addEventListener('click', ()=> __startGame(true));
  document.getElementById('startBtn').addEventListener('pointerup', ()=> __startGame(true));
  document.getElementById('startNoAudioBtn').addEventListener('pointerup', ()=> __startGame(false));
  window.addEventListener('keydown', (e)=>{ if(overlay && !overlay.classList.contains('hidden') && (e.key==='Enter' || e.key===' ')){ e.preventDefault(); __startGame(true); } }, true);

  function bindHold(btn, onPress, onRelease){
    btn.addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); try{ btn.setPointerCapture(e.pointerId);}catch{} onPress(); });
    const end = e=>{ e.preventDefault(); onRelease && onRelease(); };
    ['pointerup','pointercancel','pointerleave'].forEach(ev=> btn.addEventListener(ev, end));
    btn.addEventListener('touchend', end, {passive:false});
    btn.addEventListener('touchcancel', end, {passive:false});
    btn.addEventListener('contextmenu', e=> e.preventDefault());
  }
  bindHold(document.getElementById('mLeft'), ()=>{ taps.left++; setLeft(true); }, ()=> setLeft(false));
  bindHold(document.getElementById('mRight'), ()=>{ taps.right++; setRight(true); }, ()=> setRight(false));
  bindHold(document.getElementById('mSoft'), ()=> setDown(true), ()=> setDown(false));
  document.getElementById('mRotate').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); rotate(); });
  document.getElementById('mHard').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); hardDrop(); });
})();
</script>
</body>
</html>
