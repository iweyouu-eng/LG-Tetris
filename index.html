<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Tetris (NES 룰) + BGM v4.9.7-dbgsafe</title>
<style>
  :root { --bg:#0f1115; --panel:rgba(255,255,255,0.06); --accent:#7dd3fc; --btn:#1f2937; --btnBorder:rgba(255,255,255,.18); }
  html, body { margin:0; padding:0; height:100%; background:linear-gradient(180deg,#0f1115,#0b0d11); color:#e5e7eb; font:14px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,Arial,sans-serif; overscroll-behavior: none; -webkit-text-size-adjust: 100%; }
  .wrap { max-width:1100px; margin:0 auto; padding:10px; display:grid; grid-template-columns: 1fr; gap:10px; padding-bottom: calc(90px + env(safe-area-inset-bottom)); }
  @media (min-width: 950px){ .wrap { grid-template-columns: 0.9fr 1.1fr; padding-bottom: 10px; } }
  .card { background: var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:10px; }
  #stage { position:relative; display:flex; justify-content:center; align-items:center; min-height:60vh; touch-action:none; overscroll-behavior: contain; }
  #game { background:#111; border:1px solid rgba(255,255,255,.1); border-radius:8px; image-rendering: pixelated; outline:none; touch-action:none; -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: rgba(0,0,0,0); }
  #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.55); border-radius:10px; z-index:1500; }
  #overlay.hidden { display:none; }
  #overlay .box { text-align:center; }
  .btn { background:var(--btn); color:#fff; border:1px solid var(--btnBorder); border-radius:12px; padding:10px 12px; cursor:pointer; }
  .btn:disabled{ opacity:.5; cursor:not-allowed; }

  /* ===== Debug HUD (obstruction-safe) ===== */
  #dbg {
    position:fixed; z-index:1400; font-size:11px; line-height:1.25;
    color:#e5e7eb; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15);
    border-radius:10px; padding:6px 8px; max-width:80vw; max-height:32vh; overflow:auto;
    backdrop-filter: blur(2px);
    right:10px; bottom:110px; /* Desktop default */
    -webkit-user-select: none; user-select: none;
  }
  /* Mobile default: top-left, safe-area aware */
  @media (max-width: 950px){
    #dbg { left: calc(8px + env(safe-area-inset-left)); top: calc(8px + env(safe-area-inset-top)); right:auto; bottom:auto; }
  }
  /* Collapsed pill */
  #dbg.collapsed {
    padding:3px 6px; max-width:unset; max-height:unset; overflow:hidden;
    background:rgba(0,0,0,.40); border-radius:9999px; border-color:rgba(255,255,255,.12);
    box-shadow: 0 3px 10px rgba(0,0,0,.35);
  }
  #dbg.collapsed::before { content:"DBG"; font-weight:700; letter-spacing:.4px; font-size:10px; opacity:.9; }
  #dbg.collapsed { cursor:pointer; }
  #dbg.hint::after { content:"  (더블탭/더블클릭)"; font-size:10px; opacity:.6; }
</style>
</head>
<body>
<button id="startFab" title="시작이 안 눌리면 이걸 탭하세요">▶ 시작</button>
<div id="dbg" class="collapsed hint"></div>
<div class="wrap">
  <div class="card" id="stage">
    <canvas id="game" width="320" height="640" tabindex="0"></canvas>
    <div id="overlay">
      <div class="box">
        <h2 style="margin:0 0 10px 0;">Tetris (NES) + BGM</h2>
        <p class="note">시작을 누르면 오디오 권한이 활성화되고 BGM이 재생됩니다.</p>
        <div style="display:flex; gap:8px; justify-content:center;">
          <button id="startBtn" class="btn" onclick="window.__startGameFromUI&&window.__startGameFromUI(true)">▶ 시작</button>
          <button id="startNoAudioBtn" class="btn" onclick="window.__startGameFromUI&&window.__startGameFromUI(false)">음악 없이 시작</button>
        </div>
      </div>
    </div>
    <audio id="bgmAudio" preload="auto"></audio>
  </div>
  <div class="card" id="controlsCard">
    <div class="controls">
      <div class="row">
        <button id="btnPause" class="btn">⏸ 일시정지</button>
        <button id="btnReset" class="btn">↺ 리셋</button>
        <span class="sep"></span>
        <label>트랙: 
          <select id="trackSel">
            <option value="A" selected>A</option>
            <option value="B">B</option>
            <option value="C">C</option>
          </select>
        </label>
        <label>🎵 BGM <input type="checkbox" id="bgmToggle" checked></label>
        <label>볼륨 <input id="bgmVol" type="range" min="0" max="1" step="0.01" value="0.6" style="width:120px;"></label>
      </div>
      <div class="row">
        <label><input type="checkbox" id="cycleABC" checked> ABC 자동 순환</label>
        <span class="sep"></span>
        <span id="loopRow">
          <label>Loop 사용 <input type="checkbox" id="loopEnable"></label>
          <label>시작(s) <input type="number" id="loopStart" value="0" step="0.1"></label>
          <label>끝(s) <input type="number" id="loopEnd" value="9999" step="0.1"></label>
          <button id="setStart" class="btn">현재→시작</button>
          <button id="setEnd" class="btn">현재→끝</button>
        </span>
      </div>
      <div class="row">
        <label>Fade In(s) <input type="number" id="fadeIn" value="1.0" min="0" max="10" step="0.1"></label>
        <label>Fade Out(s) <input type="number" id="fadeOut" value="0.6" min="0" max="10" step="0.1"></label>
        <button id="testFade" class="btn">페이드 테스트</button>
      </div>
      <div class="row">
        <label><input type="checkbox" id="lockKeys" checked> 키 입력을 게임에 고정</label>
        <label><input type="checkbox" id="enableHardDrop"> Space=하드드롭(옵션)</label>
        <span class="sep"></span>
        <label>DAS(ms) <input type="number" id="dasMs" value="130" min="0" max="500" step="10"></label>
        <label>ARR(ms) <input type="number" id="arrMs" value="50" min="0" max="200" step="5"></label>
        <label>Soft(ms) <input type="number" id="softMs" value="50" min="0" max="200" step="5"></label>
      </div>
    </div>
  </div>
</div>

<!-- Mobile Controls (fixed bottom) -->
<div id="mobileControls">
  <div class="cluster left">
    <div class="mbtn" id="mLeft" title="Left">◀</div>
    <div class="mbtn" id="mRight" title="Right">▶</div>
  </div>
  <div class="cluster right">
    <div class="mbtn" id="mRotate" title="Rotate">⟳</div>
    <div class="mbtn" id="mSoft" title="Soft Drop">↓</div>
    <div class="mbtn" id="mHard" title="Hard Drop">⤓</div>
  </div>
</div>

<script>
(function(){
  const dbgEl = document.getElementById('dbg');
  const overlay = document.getElementById('overlay');
  const startFab = document.getElementById('startFab');
  const controlsCard = document.getElementById('controlsCard');
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled=false;
  function dbg(o){ try{ if(!dbgEl) return; if(dbgEl.classList.contains('collapsed')) return; dbgEl.textContent = JSON.stringify(o); }catch{} }

  // Tiny DBG pill (double-tap/click to expand/collapse)
  let lastTap=0;
  function toggleDbg(){ dbgEl.classList.toggle('collapsed'); dbgEl.classList.remove('hint'); }
  dbgEl.addEventListener('click', ()=>{ if(dbgEl.classList.contains('collapsed')) toggleDbg(); });
  dbgEl.addEventListener('dblclick', (e)=>{ e.preventDefault(); toggleDbg(); });
  dbgEl.addEventListener('touchend', (e)=>{
    const now=Date.now(); if(now-lastTap<320){ e.preventDefault(); toggleDbg(); } lastTap=now;
  }, {passive:false});

  // iOS double-tap & pinch zoom blocker
  (function(){
    let lastTouch = 0;
    const blockDbl = (e)=>{ const now=Date.now(); if(now-lastTouch<350){ e.preventDefault(); e.stopPropagation(); } lastTouch=now; };
    const blockAll = (e)=>{ e.preventDefault(); e.stopPropagation(); };
    ['dblclick'].forEach(ev => document.addEventListener(ev, blockAll, {passive:false, capture:true}));
    ['touchend'].forEach(ev => document.addEventListener(ev, blockDbl, {passive:false, capture:true}));
    ['gesturestart','gesturechange','gestureend'].forEach(ev => document.addEventListener(ev, blockAll, {passive:false, capture:true}));
  })();

  // ===== BGM (ABC cycle) =====
  const TRACKS = { A:'bgm_A.mp3', B:'bgm_B.mp3', C:'bgm_C.mp3' };
  const order = ['A','B','C'];
  const bgmEl = document.getElementById('bgmAudio');
  const trackSel = document.getElementById('trackSel');
  const bgmToggle = document.getElementById('bgmToggle');
  const bgmVol = document.getElementById('bgmVol');
  const cycleToggle = document.getElementById('cycleABC');
  const loopRow = document.getElementById('loopRow');
  const loopEnable = document.getElementById('loopEnable');
  const loopStartEl = document.getElementById('loopStart');
  const loopEndEl = document.getElementById('loopEnd');
  const setStartBtn = document.getElementById('setStart');
  const setEndBtn = document.getElementById('setEnd');
  const fadeInEl = document.getElementById('fadeIn');
  const fadeOutEl = document.getElementById('fadeOut');
  const testFadeBtn = document.getElementById('testFade');

  let audioCtx=null, srcNode=null, volGain=null, fadeGain=null;
  let loopStart=0, loopEnd=9999, loopOn=false;
  let userVol=parseFloat(bgmVol.value);
  let currentIndex = 0; function idxOf(val){ const i=order.indexOf(val); return i>=0? i:0; }

  async function initAudio(){
    if(audioCtx) return true;
    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      await audioCtx.resume();
      srcNode = audioCtx.createMediaElementSource(bgmEl);
      volGain = audioCtx.createGain();
      fadeGain = audioCtx.createGain();
      volGain.gain.value = userVol;
      fadeGain.gain.value = 1.0;
      srcNode.connect(volGain).connect(fadeGain).connect(audioCtx.destination);
      return true;
    }catch(e){ console.warn('오디오 초기화 실패', e); return false; }
  }
  function fadeTo(target,dur){ if(!audioCtx||!fadeGain) return; const g=fadeGain.gain, now=audioCtx.currentTime; try{ g.setValueAtTime(g.value,now); g.linearRampToValueAtTime(target, now+Math.max(0,dur||0)); }catch{} }
  function applyLoopInputs(){ loopOn=!!loopEnable.checked; loopStart=parseFloat(loopStartEl.value)||0; loopEnd=parseFloat(loopEndEl.value)||9999; if(loopEnd<=loopStart+0.05){ loopOn=false; } loopRow.classList.toggle('muted', cycleToggle.checked); bgmEl.loop = cycleToggle.checked? false : !loopOn; }
  function setTrackByIndex(i, withFade=true){
    currentIndex = (i%order.length + order.length)%order.length;
    const name = order[currentIndex];
    trackSel.value = name;
    const url = TRACKS[name];
    const wasPlaying = !bgmEl.paused;
    const out = withFade? (parseFloat(fadeOutEl.value)||0):0;
    const inn = withFade? (parseFloat(fadeInEl.value)||0):0;
    const swap = ()=>{
      bgmEl.pause();
      bgmEl.src = url;
      bgmEl.currentTime = loopStart||0;
      bgmEl.load();
      if(bgmToggle.checked){
        bgmEl.play().then(()=>{ if(withFade) fadeTo(1.0,inn); }).catch((e)=>{ console.warn('play 실패', e); });
      }
    };
    if(wasPlaying && out>0){ fadeTo(0.0,out); setTimeout(swap, out*1000); } else swap();
  }
  function setTrack(name){ setTrackByIndex(idxOf(name)); }
  function nextTrack(skipFade=false){ setTrackByIndex(currentIndex+1, !skipFade); }
  bgmEl.addEventListener('ended', ()=>{ if(cycleToggle.checked) nextTrack(); });
  bgmEl.addEventListener('error', ()=>{ console.warn('BGM 로드 실패: '+bgmEl.src); if(cycleToggle.checked){ currentIndex=(currentIndex+1)%order.length; setTrackByIndex(currentIndex, false); }});
  bgmVol.addEventListener('input', ()=>{ userVol=parseFloat(bgmVol.value)||0; if(volGain) volGain.gain.value=userVol; });
  bgmToggle.addEventListener('change', ()=>{ if(!audioCtx) return; if(bgmToggle.checked){ const inn=parseFloat(fadeInEl.value)||0; bgmEl.play().then(()=>fadeTo(1.0,inn)).catch(()=>{});} else { const out=parseFloat(fadeOutEl.value)||0; fadeTo(0.0,out); setTimeout(()=>bgmEl.pause(), out*1000);} });
  trackSel.addEventListener('change', ()=> setTrack(trackSel.value));
  testFadeBtn.addEventListener('click', ()=>{ const out=parseFloat(fadeOutEl.value)||0, inn=parseFloat(fadeInEl.value)||0; fadeTo(0.0,out); setTimeout(()=>{ if(bgmEl.paused) bgmEl.play().catch(()=>{}); fadeTo(1.0,inn); }, Math.max(1,out*1000+200)); });
  cycleToggle.addEventListener('change', applyLoopInputs);
  loopEnable.addEventListener('change', applyLoopInputs);
  loopStartEl.addEventListener('input', applyLoopInputs);
  loopEndEl.addEventListener('input', applyLoopInputs);
  setStartBtn.addEventListener('click', ()=>{ loopStartEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });
  setEndBtn.addEventListener('click', ()=>{ loopEndEl.value=bgmEl.currentTime.toFixed(2); applyLoopInputs(); });

  // ===== Game core (v4.9.7) =====
  const COLS=10, ROWS=20, SIZE=32;
  const COLORS={ I:'#67e8f9', J:'#60a5fa', L:'#f59e0b', O:'#fef08a', S:'#34d399', T:'#c084fc', Z:'#f87171', X:'#0b0d12' };
  const SHAPES={ I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0],[0,0,0]], Z:[[1,1,0],[0,1,1],[0,0,0]], T:[[0,1,0],[1,1,1],[0,0,0]] };
  const TYPES=['I','J','L','O','S','T','Z'];
  let prevType=null; function pickType(){ const roll=()=>TYPES[(Math.random()*TYPES.length)|0]; let t=roll(); if(prevType&&t===prevType) t=roll(); prevType=t; return t; }
  const GFRAMES={ 0:48,1:43,2:38,3:33,4:28,5:23,6:18,7:13,8:8,9:6,10:5,11:5,12:5,13:4,14:4,15:4,16:3,17:3,18:3,19:2,20:2,21:2,22:2,23:2,24:2,25:2,26:2,27:2,28:2,29:1 };
  function gravityMsForLevel(lv){ const frames=GFRAMES[Math.min(29,lv)] ?? 48; return Math.max(16, frames*(1000/60)); }

  let board=makeBoard(); let current=null; let nextType=pickType(); let dropInterval=gravityMsForLevel(0); let acc=0; let running=false; let lines=0, level=0; let lastTime=0;
  const dasEl=document.getElementById('dasMs'), arrEl=document.getElementById('arrMs'), softEl=document.getElementById('softMs');
  let dasMs=parseFloat(dasEl.value)||130, arrMs=parseFloat(arrEl.value)||50, softMs=parseFloat(softEl.value)||50;
  dasEl.addEventListener('input', ()=> dasMs=Math.max(0,parseFloat(dasEl.value)||0));
  arrEl.addEventListener('input', ()=> arrMs=Math.max(0,parseFloat(arrEl.value)||0));
  softEl.addEventListener('input', ()=> softMs=Math.max(0,parseFloat(softEl.value)||0));

  const input={ left:false, right:false, down:false };
  const taps={ left:0, right:0 };
  let hDir=null; let nextHMoveAt=0, nextSoftAt=0;
  let lastY=null, lastSoftAdvanceAt=0;

  function setLeft(v){ if(v){ input.left=true; input.right=false; } else input.left=false; }
  function setRight(v){ if(v){ input.right=true; input.left=false; } else input.right=false; }
  function setDown(v){ input.down=!!v; if(!v){ const now=performance.now(); nextSoftAt = now + softMs; } }

  const lockKeysEl=document.getElementById('lockKeys');
  function isGameKey(k){ return (k==='ArrowLeft'||k==='ArrowRight'||k==='ArrowDown'||k==='ArrowUp'||k==='x'||k==='X'||k===' '||k==='p'||k==='P'||k==='r'||k==='R'); }
  function captureKey(e){
    if(!isGameKey(e.key)) return;
    if(!running) return;
    if(lockKeysEl.checked){ e.preventDefault(); }
    canvas.focus({preventScroll:true});
  }
  document.addEventListener('keydown', captureKey, {capture:true});
  document.addEventListener('keyup', captureKey, {capture:true});
  document.addEventListener('pointerdown', ()=>{ if(running) canvas.focus({preventScroll:true}); }, {passive:true});

  // Mobile buttons
  function bindHold(btn, onPress, onRelease){
    btn.addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); try{ btn.setPointerCapture(e.pointerId);}catch{} onPress(); });
    const end = e=>{ e.preventDefault(); onRelease && onRelease(); };
    ['pointerup','pointercancel','pointerleave'].forEach(ev=> btn.addEventListener(ev, end));
    btn.addEventListener('touchend', end, {passive:false});
    btn.addEventListener('touchcancel', end, {passive:false});
    btn.addEventListener('contextmenu', e=> e.preventDefault());
  }
  bindHold(document.getElementById('mLeft'), ()=>{ taps.left++; setLeft(true); }, ()=> setLeft(false));
  bindHold(document.getElementById('mRight'), ()=>{ taps.right++; setRight(true); }, ()=> setRight(false));
  bindHold(document.getElementById('mSoft'), ()=> setDown(true), ()=> setDown(false));
  document.getElementById('mRotate').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); rotate(); });
  document.getElementById('mHard').addEventListener('pointerdown', e=>{ e.preventDefault(); e.stopPropagation(); hardDrop(); });

  // Keyboard actions
  window.addEventListener('keydown', (e)=>{
    const k=e.key; if(!isGameKey(k)) return;
    if(k==='ArrowLeft'){ taps.left++; setLeft(true); }
    else if(k==='ArrowRight'){ taps.right++; setRight(true); }
    else if(k==='ArrowDown'){ setDown(true); }
    else if(k==='ArrowUp'||k==='x'||k==='X'){ rotate(); }
    else if(k===' ' && document.getElementById('enableHardDrop').checked){ hardDrop(); }
    else if(k==='p'||k==='P'){ running=!running; if(running) canvas.focus({preventScroll:true}); }
    else if(k==='r'||k==='R'){ resetGame(); }
  });
  window.addEventListener('keyup', (e)=>{ const k=e.key; if(k==='ArrowLeft') setLeft(false); else if(k==='ArrowRight') setRight(false); else if(k==='ArrowDown') setDown(false); });

  function makeBoard(){ const b=[]; for(let r=0;r<ROWS;r++) b[r]=new Array(COLS).fill(null); return b; }
  function clone(m){ return m.map(row=>row.slice()); }
  function rotateCW(m){ const h=m.length,w=m[0].length; const out=[]; for(let x=0;x<w;x++){ const row=[]; for(let y=h-1;y>=0;y--){ row.push(m[y][x]); } out.push(row);} return out; }
  function getShape(t){ return clone(SHAPES[t]); }

  function spawn(){ const t=nextType; nextType=pickType(); current={ t, m:getShape(t), x:(COLS/2|0)-2, y:-2 }; lastY=current.y; if(collides(current,current.x,current.y)){ gameOver(); } }
  function collides(piece,nx,ny,nm){ const m=nm||piece.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=nx+x, by=ny+y; if(bx<0||bx>=COLS||by>=ROWS) return true; if(by>=0 && board[by][bx]) return true; } return false; }
  function tryMove(dx,dy){ const nx=current.x+dx, ny=current.y+(dy||0); if(!collides(current,nx,ny)){ current.x=nx; current.y=ny; return true; } return false; }
  function rotate(){ let nm=rotateCW(current.m); if(!collides(current,current.x,current.y,nm)) current.m=nm; }
  function softStep(){ if(!tryMove(0,1)) lock(); }
  function hardDrop(){ while(tryMove(0,1)){} lock(); }
  function lock(){ const m=current.m; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(!m[y][x]) continue; const bx=current.x+x, by=current.y+y; if(by>=0) board[by][bx]=current.t; } clearLines(); spawn(); }
  function clearLines(){ let cleared=0; for(let r=ROWS-1;r>=0;r--){ if(board[r].every(v=>!!v)){ board.splice(r,1); board.unshift(new Array(COLS).fill(null)); cleared++; r++; } } if(cleared>0){ if((lines+=cleared) >= (level+1)*10){ level++; dropInterval=gravityMsForLevel(level); } } }

  function handleHorizontal(now){
    if(taps.left>0){ tryMove(-1,0); taps.left=0; hDir='L'; nextHMoveAt=now+dasMs; }
    else if(taps.right>0){ tryMove(1,0); taps.right=0; hDir='R'; nextHMoveAt=now+dasMs; }
    const want=input.left?'L':input.right?'R':null;
    if(!want){ hDir=null; return; }
    if(want!==hDir){ hDir=want; tryMove(hDir==='L'?-1:1,0); nextHMoveAt=now+dasMs; return; }
    while(now>=nextHMoveAt){ if(!tryMove(hDir==='L'?-1:1,0)) break; nextHMoveAt+=arrMs; if(arrMs<=0) break; }
  }
  function validTime(t){ return Number.isFinite(t) && t<=1e13; }
  function handleSoft(now){
    if(!input.down){ nextSoftAt = now + softMs; lastSoftAdvanceAt = now; return; }
    if(!validTime(nextSoftAt)){ nextSoftAt = now + softMs; }
    while(now>=nextSoftAt){
      if(!tryMove(0,1)){ lock(); lastSoftAdvanceAt = now; break; }
      lastSoftAdvanceAt = now; nextSoftAt += softMs; if(softMs<=0) break;
    }
    if(input.down){
      if(lastY===null) lastY=current.y;
      if(current.y===lastY && (now - lastSoftAdvanceAt) > Math.max(150, softMs*3)){
        if(tryMove(0,1)){ lastSoftAdvanceAt = now; nextSoftAt = now + softMs; }
      }
    }
    lastY = current.y;
  }
  function update(dt){
    if(!running){ return; }
    if(!current){ spawn(); }
    acc += dt; const now=performance.now();
    handleHorizontal(now); handleSoft(now);
    if(acc>=dropInterval){
      if(!input.down || (now - lastSoftAdvanceAt) > Math.max(300, softMs*4)){
        if(!tryMove(0,1)) lock();
      }
      acc=0;
    }
    dbg({running, y:current?current.y:null, down:input.down});
  }
  function drawCell(c,x,y,s,color){ c.fillStyle=color; c.fillRect(x,y,s,s); c.strokeStyle='rgba(0,0,0,0.35)'; c.lineWidth=2; c.strokeRect(x+1,y+1,s-2,s-2); c.strokeStyle='rgba(255,255,255,0.12)'; c.lineWidth=2; c.strokeRect(x+0.5,y+0.5,s-1,s-1); }
  function render(){ const rect=stage.getBoundingClientRect(); const wScale=Math.floor(rect.width/(COLS*SIZE)), hScale=Math.floor(rect.height/(ROWS*SIZE)), scale=Math.max(1, Math.min(wScale,hScale)); canvas.style.width=(COLS*SIZE*scale)+'px'; canvas.style.height=(ROWS*SIZE*scale)+'px'; ctx.clearRect(0,0,canvas.width,canvas.height); for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const t=board[y][x]; drawCell(ctx,x*SIZE,y*SIZE,SIZE,t?COLORS[t]:COLORS.X); } if(current){ const m=current.m, color=COLORS[current.t]; for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++){ if(m[y][x]) drawCell(ctx,(current.x+x)*SIZE,(current.y+y)*SIZE,SIZE,color); } } }
  function loop(ts){ requestAnimationFrame(loop); render(); update(ts - (window.__last||ts)); window.__last = ts; }
  function gameOver(){ running=false; resetGame(true); }
  function resetGame(keepOverlay){ board=makeBoard(); current=null; nextType=pickType(); dropInterval=gravityMsForLevel(level=0); lastTime=0; acc=0; lines=0; if(!keepOverlay){ overlay.classList.remove('hidden'); startFab.classList.remove('hidden'); } }

  // Start
  async function __startGame(startAudio=true){
    if(startAudio){ const ok = await initAudio(); applyLoopInputs(); setTrackByIndex(order.indexOf(trackSel.value), false); if(!ok){ console.warn('오디오 권한/초기화 실패 – 게임은 무음으로 시작'); } }
    overlay.classList.add('hidden'); startFab.classList.add('hidden');
    if(current==null) spawn(); running = true; requestAnimationFrame(loop); canvas.focus({preventScroll:true});
  }
  window.__startGameFromUI = __startGame;

  document.getElementById('startBtn').addEventListener('click', ()=> __startGame(true));
  document.getElementById('startNoAudioBtn').addEventListener('click', ()=> __startGame(false));
  startFab.addEventListener('click', ()=> __startGame(true));
  document.getElementById('startBtn').addEventListener('pointerup', ()=> __startGame(true));
  document.getElementById('startNoAudioBtn').addEventListener('pointerup', ()=> __startGame(false));
  window.addEventListener('keydown', (e)=>{ if(overlay && !overlay.classList.contains('hidden') && (e.key==='Enter' || e.key===' ')){ e.preventDefault(); __startGame(true); } }, true);
})();
</script>
</body>
</html>
